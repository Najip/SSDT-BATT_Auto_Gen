#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import os
import re
from multilanguage import *
import time


class AutoGen:
    OR_info = []
    verbose = False
    debug = False
    head = """DefinitionBlock ("", "SSDT", 2, "ERIC", "BATT", 0x00000000)
{"""
    RW_method = ""
    comment = ""

    def __init__(self) -> None:
        self.parse_args()
        self.out_handle()
        self.clean_out()
        self.split_dsdt()
        self.EC_content = self.get_content("\"PNP0C09\"")
        self.find_OperationRegion()
        self.find_field()
        self.patch_method()
        self.insert_osi()
        self.special_devices()
        self.generate_comment()
        self.assemble()
        self.write_file()

    def show_help(self):
        print(HELP_MESSAGE)

    def parse_args(self):
        arg_lens = len(sys.argv)
        if arg_lens == 1:
            self.show_help()
            exit()
        for arg in sys.argv:
            if '-h' in arg or 'help' in arg:
                self.show_help()
                exit()
            if '-v' in arg:
                self.verbose = True
            if '-debug' in arg:
                self.verbose = True
                self.debug = True
            if '.dsl' in arg:
                self.filename = arg
                self.filepath = os.path.abspath(arg)
                try:
                    with open(self.filename, 'r') as f:
                        self.dsdt_content = f.read()
                except FileNotFoundError:
                    print(FILE_NOT_FOUND_ERR)
                    exit(1)
                except PermissionError:
                    print(PERMISSION_ERR)
                    exit(1)

    def out_handle(self):
        result = re.findall("PNP0C0A", self.dsdt_content)
        if len(result) > 1:
            print(TOO_MANY_BATT_ERR)
            exit(1)
        elif len(result) < 1:
            print(TOO_FEW_BATT_ERR)
            exit(1)

    def clean_out(self):
        '''
        Removes comments, external, Firmware error generated by iasl, etc
        '''
        # Remove block comments
        self.dsdt_content = re.sub(
            r'/\*[\w\W\n]*?\*/', "", self.dsdt_content)
        # Remove line comments
        self.dsdt_content = re.sub(r'//.*', '', self.dsdt_content)
        # Remove "External" declaration
        self.dsdt_content = re.sub(r'External \(.*Obj\)\n', "", self.dsdt_content)
        # Remove "Firmware Error" that generated within disassambling
        self.dsdt_content = re.sub(
            r'Firmware Error.*\n', "", self.dsdt_content)
        # Remove empty lines
        self.dsdt_content = re.sub(r'^\n', "", self.dsdt_content)

    def split_dsdt(self):
        self.dsdt_splited = self.dsdt_content.split(' ')
        if self.debug:
            length = len(self.dsdt_splited)
            for i in range(0, length):
                # remove spaces
                i = length - i - 1
                if self.dsdt_splited[i] == '':
                    del self.dsdt_splited[i]
        

    def get_content(self, target: str):
        '''
        Getting file content about given target.

        If target is a path, return its content in string. 

        If target is a word, return the method which includes it in a dict. 

        @param: target(str) - device/field/method absolute path or query word (determine by ' \ ')

        @return: content(str) - file content about that device/field/method

        @return: content(dict) - {"path": "content"}
        '''
        if self.debug:
            print('\n\n')
            print("---------------------get content-----------------------")
        dsdt_splited = self.dsdt_splited
        stack = []
        trigger = False
        is_string = False
        content = ''
        path_list = []  # Find path by word

        for i in range(0, len(dsdt_splited)):
            word = dsdt_splited[i]
            if '\\' not in target:
                if target in dsdt_splited[i]:
                    word = dsdt_splited[i]
                    if target != dsdt_splited[i] and not re.match('\\(*"?%s,?"?\\)*$' % target, dsdt_splited[i]) and not re.match('.*\\.%s' % target, dsdt_splited[i]):
                        # 跳过非该变量名结尾的情况
                        continue
                    path = ''
                    for item in stack:
                        if item:
                            if item[0] == 'Scope':
                                if item[1].startswith('\\'):
                                    path = item[1]
                                else:
                                    path = '\\' + item[1]
                            elif item[0] == 'Device':
                                if stack.index(item) != 1:
                                    path += '.'
                                else:
                                    path = '\\'
                                path += item[1]
                            elif item[0] == 'Method':
                                if stack.index(item) != 1:
                                    path += '.'
                                else:
                                    path = '\\'
                                path += item[1]
                            elif item[0] == "Field":
                                # avoid searching Field
                                path = None
                    if path:
                        path_list.append(path)
            if '"' in dsdt_splited[i]:
                count = dsdt_splited[i].count('"')
                for tmp in range(0, count):
                    is_string = not is_string
                continue
            if dsdt_splited[i] == "DefinitionBlock":
                stack.append("DefinitionBlock")
            elif dsdt_splited[i] == "Field":
                try:
                    name = re.findall(r'\((.*),', dsdt_splited[i+1])[0]
                    trigger = True  # 触发检查当前路径
                except IndexError:
                    continue
                stack.append(("Field", name))
            elif dsdt_splited[i] == "IndexField":
                try:
                    name = re.findall(r'\((.*),', dsdt_splited[i+1])[0]
                    trigger = True  # 触发检查当前路径
                except IndexError:
                    continue
                stack.append(("IndexField", name))
            elif dsdt_splited[i] == "Scope":
                try:
                    path = re.findall(r'\((.*)\)', dsdt_splited[i+1])[0]
                    trigger = True  # 触发检查当前路径
                except IndexError:
                    continue
                stack.append(("Scope", path))
                if self.debug:
                    print("Scope", path)
            elif dsdt_splited[i] == "Method":
                try:
                    name = re.findall(r'\((.*),', dsdt_splited[i+1])[0]
                    trigger = True  # 触发检查当前路径
                except IndexError:
                    continue
                stack.append(("Method", name))
                if self.debug:
                    print("Method", name)
                    if name == "WQA0":
                        print()
            elif dsdt_splited[i] == "Device":
                try:
                    name = re.findall(r'\((.*)\)', dsdt_splited[i+1])[0]
                    trigger = True  # 触发检查当前路径
                except IndexError:
                    continue
                stack.append(("Device", name))
                if self.debug:
                    print("Device", name)
                    if name == "WMI1":
                        print()
            elif dsdt_splited[i] == "ThermalZone":
                try:
                    name = re.findall(r'\((.*)\)', dsdt_splited[i+1])[0]
                    trigger = True  # 触发检查当前路径
                except IndexError:
                    continue
                stack.append(("ThermalZone", name))

            elif dsdt_splited[i] in ("If", "(If"):
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "Else\n":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "ElseIf":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "Switch":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "Case":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "Default\n":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "While":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] in ("Buffer", "(Buffer"):
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] in ("Package", "(Package"):
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "IRQ":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "IRQNoFlags":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] in ("ResourceTemplate", "(ResourceTemplate"):
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "Interrupt":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "GpioInt":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "GpioIo":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "StartDependentFn":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "StartDependentFnNoPri":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "Processor":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] == "PowerResource":
                if not is_string:
                    stack.append(None)
            elif dsdt_splited[i] in ("DMA", "(DMA"):
                if not is_string:
                    stack.append(None)

            elif "}" in dsdt_splited[i]:
                if not is_string:
                    stack.pop()

            if trigger:
                # 触发检查当前路径
                path = ''
                for item in stack:
                    if item:
                        if item[0] == 'Scope':
                            if item[1].startswith('\\'):
                                path = item[1]
                            else:
                                path = '\\' + item[1]
                        elif item[0] == 'Device':
                            if stack.index(item) != 1:
                                path += '.'
                            else:
                                path = '\\'
                            path += item[1]
                        elif item[0] == 'Method':
                            if stack.index(item) != 1:
                                path += '.'
                            else:
                                path = '\\'
                            path += item[1]
                        elif item[0] == 'Field':
                            if stack.index(item) != 1:
                                path += '.'
                            else:
                                path = '\\'
                            path += item[1]
                        elif item[0] == 'IndexField':
                            if stack.index(item) != 1:
                                path += '.'
                            else:
                                path = '\\'
                            path += item[1]
                        elif item[0] == 'ThermalZone':
                            if stack.index(item) != 1:
                                path += '.'
                            else:
                                path = '\\'
                            path += item[1]
                if path == target:
                    # 匹配查找目标时
                    bracket_stack = []
                    for word in dsdt_splited[i:]:
                        if "{" in word:
                            bracket_stack.append('{')
                        if "}" in word:
                            bracket_stack.pop()
                            if len(bracket_stack) == 0:
                                content += word
                                break
                        content += (word+' ')
                trigger = False
        if len(path_list) > 0:
            # 关键词搜索模式时
            content = {}
            for path in path_list:
                content[path] = self.get_content(path)
        return content

    def find_OperationRegion(self):
        '''
        Find OperationRegion in EC device
        '''
        EC_content = self.EC_content
        for dev in EC_content:
            OR_list = re.findall(
                "OperationRegion \\(([A-Z]{4}),", EC_content[dev])
            for OR in OR_list:
                OR_info = re.search(  # 使用分组来获得 OperationRegion 的信息
                    "OperationRegion \\(%s, ([a-zA-Z].*), ([a-zA-Z0-9].*), ([a-zA-Z0-9].*)\\)" % OR, EC_content[dev])
                try:
                    self.OR_info.append({
                        "Path": dev,
                        "Name": OR,
                        "Storage": OR_info.group(1),
                        "Offset": OR_info.group(2),
                        "Length": OR_info.group(3)
                    })
                except AttributeError:
                    continue
        if self.verbose:
            for item in self.OR_info:
                print(item)
            print()

    def rename(self, orig_name: str):
        '''
        Method to rename anything without conflicting.

        @param: orig_name(str) - original name

        @return: new_name(str) - renamed name
        '''
        alphabet = ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                    'A', 'B', 'C', 'D', 'E', 'F', 'G',
                    'H', 'I', 'J', 'K', 'L', 'M', 'N',
                    'O', 'P', 'Q', 'R', 'S', 'T',
                    'U', 'V', 'W', 'X', 'Y', 'Z')
        for char in alphabet:
            new_name = orig_name[:3]+char
            if self.dsdt_content.find(new_name) == -1:
                return new_name

    def find_field(self):
        self.modified_fieldunit = []
        for OR_info in self.OR_info:
            OR_path = OR_info["Path"]+'.'+OR_info["Name"]
            content = self.get_content(OR_path)
            splited = content.split("}")
            for field in splited[:-1]:
                flag = False  # Is there any field that needs special R/W in this method?
                tmp = field.split('{')
                field_content = tmp[1].split('\n')
                offset_bit = 0  # Offset in bits
                name = ''
                size = 0
                for item in field_content:
                    if ',' not in item:
                        # Skip empty line
                        continue
                    elif "Offset" not in item:
                        a = item.split(',')
                        name = a[0].strip()
                        size = int(a[1].strip())
                        if size > 8 and name != '':
                            if offset_bit/8 - int(offset_bit/8) != 0:
                                print(FIELD_UNIT_OFFSET_ERR)
                                exit(2)
                            self.modified_fieldunit.append(
                                {"name": name, "offset": int(offset_bit/8), "size": size, "OR path": OR_path})
                            flag = True
                        offset_bit += size
                    else:
                        item = item.strip()
                        offset = re.search(r'Offset \((.*)\)', item).group(1)
                        offset_bit = int(offset, 16) * 8

                if flag:
                    if OR_info["Storage"] not in self.RW_method and OR_info["Path"] not in self.RW_method:
                        self.RE1B = self.rename('R1B')
                        self.RECB = self.rename('RDB')
                        self.ERM2 = self.rename('MEM')
                        self.WE1B = self.rename('W1B')
                        self.WECB = self.rename('WRB')
                    for item in self.modified_fieldunit:
                        if item["OR path"] == OR_path:
                            item["read method"] = self.RECB
                            item["write method"] = self.WECB
                        self.RW_method = '''
    Scope (%s)
    {
        Method (%s, 1, NotSerialized)
        {
            OperationRegion (%s, %s, Arg0, One)
            Field (%s, ByteAcc, NoLock, Preserve)
            {
                BYTE,   8
            }

            Return (BYTE) /* \RE1B.BYTE */
        }

        Method (%s, 2, Serialized)
        {
            // RECB or RSMB
            // Arg0 - offset in bytes from zero-based EC
            // Arg1 - size of buffer in bits
            Arg1 = ((Arg1 + 0x07) >> 0x03)
            Name (TEMP, Buffer (Arg1){})
            Arg1 += Arg0
            Local0 = Zero
            While ((Arg0 < Arg1))
            {
                TEMP [Local0] = %s (Arg0)
                Arg0++
                Local0++
            }

            Return (TEMP) /* \RECB.TEMP */
        }

        Method (%s, 2, NotSerialized)
        {
            OperationRegion (%s, %s, Arg0, One)
            Field (%s, ByteAcc, NoLock, Preserve)
            {
                BYTE,   8
            }

            BYTE = Arg1
        }

        Method (%s, 3, Serialized)
        {
            // WECB or WSMB
            // Arg0 - offset in bytes from zero-based EC
            // Arg1 - size of buffer in bits
            // Arg2 - data to be written
            Arg1 = ((Arg1 + 0x07) >> 0x03)
            Name (TEMP, Buffer (Arg1){})
            TEMP = Arg2
            Arg1 += Arg0
            Local0 = Zero
            While ((Arg0 < Arg1))
            {
                %s (Arg0, DerefOf (TEMP [Local0]))
                Arg0++
                Local0++
            }
        }
    }
''' % (OR_info["Path"], self.RE1B, self.ERM2, OR_info["Storage"], 
            self.ERM2, self.RECB, self.RE1B, self.WE1B, self.ERM2, 
            OR_info["Storage"], self.ERM2, self.WECB, self.WE1B)
        if "RECB" not in self.RW_method:
            print(NOT_NEED_TO_PATCH_MSG)
            exit(0)

    def patch_method(self):
        self.method_to_patch = {}
        # Getting method content
        for unit in self.modified_fieldunit:
            if unit['name'] == 'SMDA':
                print("trigger")
            if self.verbose:
                print("Unit:", unit)
            result = self.get_content(unit["name"])
            for name in result:
                scope = '.'.join(name.split('.')[:-1])
                if scope == "":
                    # Handle method like "Method (\WAK)"
                    scope = "\\"
                try:
                    if name in self.method_to_patch[scope] or ("EC" not in name and "EC" not in result[name]):
                        # remove duplicates, and remove fieldunit that not in EC scope
                        continue
                except KeyError:
                    if "EC" not in name and "EC" not in result[name]:
                        # Remove fieldunit that not in EC scope
                        continue
                if scope not in self.method_to_patch:
                    self.method_to_patch[scope] = {}
                self.method_to_patch[scope][name] = result[name]

        # Patching method
        for scope in self.method_to_patch:
            for method in self.method_to_patch[scope]:
                if self.verbose:
                    print("""
=============================
| Patching: %s |
=============================
""" % method)
                for unit in self.modified_fieldunit:
                    if self.verbose:
                        print("Parsing", unit)
                    # Patch field writing, e.g. UNIT = xxxx
                    reserve = re.findall("%s = (\\w+)" % unit['name'], self.method_to_patch[scope][method])
                    for item in reserve:
                        self.method_to_patch[scope][method] = self.method_to_patch[scope][method].replace(
                            "%s = %s" % (unit['name'], item), 
                            "%s (0x%X, %s, %s)" % (unit["write method"], 
                                int(unit["offset"]), unit["size"], item)
                        )

                    # Patch field writing, e.g. Store (xxxx, UNIT)
                    reserve = re.findall("Store \\((\\w+), %s\\)" % unit['name'], 
                        self.method_to_patch[scope][method])
                    for item in reserve:
                        self.method_to_patch[scope][method] = self.method_to_patch[scope][method].replace(
                            "Store (%s, %s)" % (item, unit['name']),
                            "%s (0x%X, %s, %s)" % (unit["write method"], 
                                int(unit["offset"]), unit["size"], item)
                        )

                    # Patch field reading
                    reserve = re.findall("(.*[^/])%s(\\W|\n)" % unit['name'], 
                        self.method_to_patch[scope][method])
                    for i in range(0, len(reserve)):
                        if "Method (" in reserve[i][0] or "Device (" in reserve[i][0]:
                            continue  # stop patching method that have the same name as fieldunit
                        self.method_to_patch[scope][method] = self.method_to_patch[scope][method].replace(
                            reserve[i][0]+unit['name']+reserve[i][1], 
                            '%s%s (0x%X, %s)%s' % (reserve[i][0], unit['read method'], 
                                int(unit['offset']), unit['size'], reserve[i][1]), 
                        )

                modified = False
                for unit in self.modified_fieldunit:
                    if unit['read method'] in self.method_to_patch[scope][method] or unit['write method'] in self.method_to_patch[scope][method]:
                        modified = True
                if not modified:
                    self.method_to_patch[scope][method] = None
                


    def insert_osi(self):
        for scope in self.method_to_patch:
            for method in self.method_to_patch[scope]:
                if not self.method_to_patch[scope][method]:
                    # Skip deleted method
                    continue
                stack = []
                method_info = re.search(
                    'Method \((\\\?[\w\.]+), (\d+), (NotSerialized|Serialized)\)', 
                    self.method_to_patch[scope][method]).groups()

                # Insert if _OSI at the beginning
                self.method_to_patch[scope][method] = re.sub(
                    'Method \((\\\?[\w\.]+), (\d+), (NotSerialized|Serialized)\)', 
                    "Method (%s, %s, %s) \n{ \nIf (_OSI (\"Darwin\"))" % (
                    method_info[0], method_info[1], method_info[2]), 
                    self.method_to_patch[scope][method])

                for index in range(0, len(self.method_to_patch[scope][method])):
                    if "{" in self.method_to_patch[scope][method][index]:
                        stack.append('{')
                    if "}" in self.method_to_patch[scope][method][index]:
                        stack.pop()
                        if len(stack) == 1:
                            arg = ''
                            for i in range(0, int(method_info[1])):
                                if i > 0:
                                    arg += ', '
                                arg += 'Arg%d' % i
                            # Insert return original method at the bottom
                            self.method_to_patch[scope][method] = self.method_to_patch[scope][method][:index] + \
                                "}\n        Else\n        {\n            Return(X%s(%s))\n        }\n" % (
                                method_info[0][-3:], arg) + self.method_to_patch[scope][method][index:]
                            break

                stack = []
                splited = self.method_to_patch[scope][method].split('\n')
                # Parse line by line
                for index in range(0, len(splited)):
                    # Delete space at front of each line
                    splited[index] = splited[index].strip()
                    if '}' in splited[index]:
                        if '{' not in splited[index]:
                            stack.pop()
                    # Indent by brackets
                    splited[index] = "    " * (len(stack) + 2) + splited[index]
                    if '{' in splited[index]:
                        if '}' not in splited[index]:
                            stack.append('{')

                self.method_to_patch[scope][method] = '\n'.join(splited)

    def patch_ACEL(self):
        print("Patching ACEL...")
        content = self.get_content("(ACEL)")
        for dev in content:
            if dev not in self.method_to_patch:
                self.method_to_patch[dev] = {}
            self.method_to_patch[dev]["%s._STA"%dev] = '''        Method (_STA, 0, NotSerialized) 
        {
            If (_OSI("Darwin")) 
            {
                Return (0)
            }
            Else 
            {
                Return(XSTA())        // May cause Windows keyboard stop after sleep
            }
        }
'''

    def special_devices(self):
        '''
        This method automatically patch some special laptops. For example, some HP laptop have ACEL device, 
        which will cause battery info not able to be updated.
        '''
        if "Device (ACEL)" in self.dsdt_content:
            if "HPQOEM" not in self.dsdt_content:
                print(IS_THIS_HP_LAPTOP)
                inp = input()
                if inp == 'yes' or inp == 'y':
                    self.patch_ACEL()
            self.patch_ACEL()

    def generate_comment(self):
        # Find mutex and set them to zero
        mutex = re.findall("Mutex \((.*?), (.*?)\)", self.dsdt_content)
        for item in mutex:
            name = item[0]
            value = int(item[1], 16)
            find = replace = '01'
            if value != 0:
                for c in name:
                    asc = ord(c)
                    find += "%02X" % asc
                    replace += "%02X" % asc
                find += "%02X" % value
                replace += "00"
                self.comment += '''// Set mutex %s to zero
// Find:    %s
// Replace: %s

''' % (name, find, replace)

        # generate ACPI patch
        for scope in self.method_to_patch:
            for method in self.method_to_patch[scope]:
                if not self.method_to_patch[scope][method]:
                    # Skip deleted method
                    continue
                method_info = list(re.search("Method \((.*?), (\d+?), (Serialized|NotSerialized)\)", 
                    self.method_to_patch[scope][method]))
                method_info[1] = method_info[1].replace("\\", "")
                method_info[2] = int(method_info[2])
                if method_info[3] == 'Serialized':
                    method_info[2] += 8
                find = replace = ''
                for c in method_info[1]:
                    asc = ord(c)
                    find += "%02X" % asc
                    replace += "%02X" % asc
                replace = "58" + replace[2:]  # Set the 1st character to 'X'
                find += "%02X" % method_info[2]
                replace += "%02X" % method_info[2]
                self.comment += '''// Rename %s to X%s
// Find:    %s
// Replace: %s

''' % (method_info[1], method_info[1][1:], find, replace)

    def assemble(self):
        self.file_generated = self.comment
        self.file_generated += (self.head + self.RW_method)
        for scope in self.method_to_patch:
            have_method = False
            for method in self.method_to_patch[scope]:
                if self.method_to_patch[scope][method]:
                    have_method = True
            if not have_method:
                # Skip empty scope
                continue
            self.file_generated += "    Scope (%s)\n    {\n" % scope
            for method in self.method_to_patch[scope]:
                if not self.method_to_patch[scope][method]:
                    # Skip deleted method
                    continue
                self.file_generated += self.method_to_patch[scope][method] + '\n'
            self.file_generated += "    }\n"
        self.file_generated += '}\n'

    def write_file(self):
        out_path = []
        out_path.append(os.getcwd() + os.sep + 'Product')
        out_path.append(self.filename.replace("DSDT", "SSDT-BATT"))
        out_path[1] = out_path[1].replace("dsdt", "SSDT-BATT")
        out_path[1] = re.sub('.*/', '', out_path[1])

        if not os.path.exists(out_path[0]):
            # If directory not exists
            os.makedirs(out_path[0])

        out_path = os.sep.join(out_path)
        try:
            with open(out_path, 'x') as f:
                f.write(self.file_generated)
                print(GENERATE_SUCCESSFUL_MSG)
        except FileExistsError:
            for i in range(1, 100):
                test = '.'.join(out_path.split('.')[:-1]) + '_%d.dsl' % i
                try:
                    with open(test, 'x') as f:
                        f.write(self.file_generated)
                        print(GENERATE_SUCCESSFUL_MSG)
                    break
                except FileExistsError:
                    pass
        
        if os.path.exists('./iasl') and os.sys.platform == "darwin":
            with os.popen("./iasl -f %s 2>&1" % out_path) as p:
                ret = p.read()
                if "AML Output" in ret:
                    print(COMPILE_SUCCESS_MSG)
                else:
                    print(ret)
        elif os.path.exists('.\\iasl.exe') and os.sys.platform == 'win32':
            with os.popen(".\\iasl.exe -f %s" % out_path) as p:
                ret = p.read()
                if "AML Output" in ret:
                    print(COMPILE_SUCCESS_MSG)
                else:
                    print(ret)
        else:
            print(TRY_TO_COMPILE_ANYWAY)
            os.system('iasl -f %s' % out_path)




if __name__ == '__main__':
    start_time = time.time()
    app = AutoGen()
    if app.verbose:
        print("程序执行用时", time.time() - start_time, "秒")
