#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import random
import re
import sys
import time

import get_content_rewrite as gc
from FieldUnit import FieldUnit
from OperationRegion import OperationRegion
from cons_strings import *
from multilanguage import *

# Third party libraies
try:
    import chardet

    __CHARDET__ = True
except ImportError:
    __CHARDET__ = False

dangerous_patch_list = ['_STA', '_CRS', '_REG', '_ADR', '_PRW', '_DCS', '_DGS', '_DSS', '_INI', '_PS0', '_PS1',
                        '_PS2', '_PS3', '_PS4', '_PS5', '_S0D', '_S1D', '_S2D', '_S3D', '_S4D', '_S5D']
VERBOSE = False
DEBUG = False
FORCE = False


class AutoGen:
    _OR_info = list()
    _PNP0C09 = list()
    _PNP0C0A = list()
    _head = HEAD
    _RW_method = ''
    _comment = ''
    _dsdt_content = ''
    _file_generated = ''
    _filepath = ''
    _method = dict()

    def __init__(self, dsdt_content: str, file_path: str) -> None:
        self._dsdt_content = dsdt_content
        self._filepath = file_path
        self._clean_out()
        self.gc = gc.GetContent(self._dsdt_content)
        EC = self.gc.search('PNP0C09')
        self._PNP0C09 = []
        for item in EC:
            EC_path = item.scope + '.' + item.name  # TODO Multiple EC support (Should just work)
            self._PNP0C09 += self.gc.get_content(EC_path)
        self._find_OperationRegion()
        self._find_unit()
        self._patch_method()
        self._PNP0C0A = self.gc.search('PNP0C0A', 'Device')
        for item in self._PNP0C0A.copy():
            a = re.findall(r'Method\s\(_STA,\s0,\sNotSerialized\)\s*\{\s*Return\s\(Zero\)\s*\}', item.content)
            if len(a) > 0:
                self._PNP0C0A.remove(item)
        if len(self._PNP0C0A) > 1:
            DUAL_BATT = True
            self._patch_dual_battery()
        else:
            DUAL_BATT = False
        self._patch_PTSWAK()
        self._insert_osi()
        self._special_devices()
        self._generate_comment()
        self._assemble(DUAL_BATT)
        self._re_indent()
        self._write_file()

    def _clean_out(self):
        '''
        Removes comments, external, Firmware error generated by iasl, etc.
        '''
        # Remove block comments
        self._dsdt_content = re.sub(
            r'/\*[\w\W\n]*?\*/', '', self._dsdt_content)
        # Remove line comments
        self._dsdt_content = re.sub(r'//.*', '', self._dsdt_content)
        # Remove 'External' declaration
        self._dsdt_content = re.sub(
            r'External.*\n', '', self._dsdt_content)
        # Remove 'Firmware Error' that generated within disassambling
        self._dsdt_content = re.sub(
            r'Firmware Error.*\n', '', self._dsdt_content)
        # Remove empty lines
        self._dsdt_content = re.sub(r'^\n', '', self._dsdt_content)

    def _find_OperationRegion(self):
        '''
        Finding OperationRegion(s) inside EC scope.
        '''
        if VERBOSE:
            print(
                'Into: find_OperationRegion(): Finding OperationRegion(s) inside EC scope.')
        for EC in self._PNP0C09.copy():
            OR_list = re.findall(
                r'OperationRegion\s\((.*?),\s.*?,\s(.*?),\s.*?\)', EC.content)
            for OR_name in OR_list.copy():
                content = self.gc.get_content(OR_name[0], 'OperationRegion')
                for item in content.copy():
                    if 'EC' in item.scope:  # Remove contents that is not in EC
                        break
                    content.remove(item)
                if len(content) == 0:
                    OR_list.remove(OR_name)
                    break
                for item in content:
                    OR_info = re.search(  # Getting info of OperationRegions by re.group
                        r'OperationRegion\s\(%s,\s([a-zA-Z].*),\s%s,\s([a-zA-Z0-9].*)\)' % OR_name, item.content)
                    try:
                        if OR_name[1] == 'Zero':
                            offset = 0
                        elif OR_name[1] == 'One':
                            offset = 1
                        elif 'Arg' in OR_name[1]:
                            continue  # TODO 处理类似 OperationRegion (NAME, Memory, Arg0, 0x01) 的情况
                        elif '0x' in OR_name[1]:
                            offset = int(OR_name[1], 16)
                        else:
                            # TODO 处理类似 OperationRegion (ECAD, SystemMemory, GNBF, 0x10) 的情况，GNBF是另一个Unit (FX503VD)
                            offset = OR_name[1]
                        self._OR_info.append(OperationRegion(
                            scope=item.scope,
                            name=OR_name[0],
                            storage=OR_info.group(1),
                            offset=offset,
                            length=OR_info.group(2)
                        ))
                    except AttributeError:
                        continue
        if VERBOSE:
            for item in self._OR_info:
                print(item)
            print()

    def _find_unit(self):
        '''
        Finding out which field unit is going to be patched inside EC scope.
        '''
        if VERBOSE:
            print(
                'Into: find_field(): Finding out which unit field is going to be patched inside EC scope.')
        for OR in self._OR_info:
            OR_path = OR.scope + '.' + OR.name
            blocks = self.gc.get_content(OR_path)
            content = ''
            for block in blocks:
                content += block.content + '\n'
            # for block in blocks:
            for field in content.split('}')[:-1]:
                field = field.split('{')[1]  # Remove field header
                store_flag = False  # Is there any field that larger than 16 bits in this method?
                field_content_splln = field.split('\n')
                offset_bits = 0  # offset in bits
                name = ''
                size = 0
                for item in field_content_splln:
                    if ',' not in item:
                        # Skip empty line
                        continue
                    elif 'Offset' not in item:
                        # Parse line such as `ABCD, 8,`
                        item_spl = item.split(',')
                        name = item_spl[0].strip()
                        size = int(item_spl[1].strip())
                        if size > 8 and name != '':
                            if offset_bits / 8 - int(offset_bits / 8) != 0:
                                print(FIELD_UNIT_OFFSET_ERR)
                                exit(2)
                            OR.append_unit(FieldUnit(
                                name=name,
                                offset=int(offset_bits / 8),
                                size=size,
                                OR_path=OR_path
                            ))
                            store_flag = True
                        offset_bits += size
                    else:
                        # Parse line such as `Offset (0x64),`
                        item = item.strip()
                        offset = re.search(r'Offset \((.*)\)', item).group(1)
                        offset_bits = int(offset, 16) * 8

                if store_flag:
                    # Store this OperationRegion and its units
                    if OR.storage not in self._RW_method:
                        while True:
                            # This will generate a new R/W method name
                            letter = random.choice(
                                '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ')
                            OR.RE1B = 'R1B' + letter
                            OR.RECB = 'REB' + letter
                            OR.ERM2 = 'MEM' + letter
                            OR.WE1B = 'W1B' + letter
                            OR.WECB = 'WRB' + letter
                            if (self._dsdt_content.find(OR.RE1B) == -1 and OR.RE1B not in self._RW_method) \
                                    and (self._dsdt_content.find(OR.RECB) == -1 and OR.RECB not in self._RW_method) \
                                    and (self._dsdt_content.find(OR.ERM2) == -1 and OR.ERM2 not in self._RW_method) \
                                    and (self._dsdt_content.find(OR.WE1B) == -1 and OR.WE1B not in self._RW_method) \
                                    and (self._dsdt_content.find(OR.WECB) == -1 and OR.WECB not in self._RW_method):
                                # Loop until there is nothing has the same name as our generated one
                                break

                        # Add the content of R/W method to self.RW_method
                        self._RW_method += RW_METHOD[0] + \
                            OR.scope + RW_METHOD[1] + \
                            OR.RE1B + RW_METHOD[2] + \
                            OR.ERM2 + RW_METHOD[3] + \
                            OR.storage + RW_METHOD[4] + \
                            OR.ERM2 + RW_METHOD[5] + \
                            OR.RECB + RW_METHOD[6] + \
                            OR.RE1B + RW_METHOD[7] + \
                            OR.WE1B + RW_METHOD[8] + \
                            OR.ERM2 + RW_METHOD[9] + \
                            OR.storage + RW_METHOD[10] + \
                            OR.ERM2 + RW_METHOD[11] + \
                            OR.WECB + RW_METHOD[12] + \
                            OR.WE1B + RW_METHOD[13]
                    else:
                        # If OR.storage in self.RW_method and not in OR itself
                        # Then copy the read/write method from other OR which has the same storage
                        for _OR_ in self._OR_info:
                            try:
                                _OR_.RE1B
                            except KeyError:
                                continue
                            if _OR_.storage == OR.storage:
                                OR.RE1B = _OR_.RE1B
                                OR.RECB = _OR_.RECB
                                OR.ERM2 = _OR_.ERM2
                                OR.WE1B = _OR_.WE1B
                                OR.WECB = _OR_.WECB
                                break

        for OR in self._OR_info:
            if len(OR.field_units) < 1:
                self._OR_info.remove(OR)

        if 'RECB' not in self._RW_method:
            print(NOT_NEED_TO_PATCH_MSG)
            exit(0)

        if VERBOSE:
            for OR in self._OR_info:
                print(OR.scope + '.' + OR.name + ', ' + OR.storage)
                for unit in OR.field_units:
                    print('  -', unit)

    def _patch_method(self):
        '''
        Getting method content by unit fields which is going to be patched. And patch each method returned.
        '''
        if VERBOSE:
            print('\nInto: patch_method().')
        for OR in self._OR_info:
            # Getting method content
            for unit in OR.field_units:
                try:
                    result = self.gc.search(unit.name, 'Method')
                except RuntimeError:
                    continue
                for block in result:
                    # if result[name].split()[0] != 'Method':
                    # Ignore content which is not Method
                    # continue
                    scope = block.scope
                    method = block.name
                    if scope == '' or method.startswith('\\'):
                        # Handle method like 'Method (\WAK)'
                        scope = '\\'
                    try:
                        if block.scope in self._method[scope] or (
                                'EC' not in block.scope and 'EC' not in block.content):
                            # remove duplicates, and remove fieldunit that not in EC scope
                            continue
                    except KeyError:
                        if 'EC' not in block.scope and 'EC' not in block.content:
                            # Remove fieldunit that not in EC scope
                            continue
                    if scope not in self._method:
                        self._method[scope] = {}
                    self._method[scope][block.name] = {
                        'content': block.content, 'modified': False}

            # Patching method
            for scope in self._method:
                for method in self._method[scope]:
                    method_content = self._method[scope][method]["content"]
                    if VERBOSE:
                        print('\n%s\n| Patching: %s |\n%s' % (
                            '=' * (14 + len(method)), method, '=' * (14 + len(method))))
                        if 'GCMD' in method:
                            print('trigger')
                    for unit in OR.field_units:
                        it_lines = iter(method_content.splitlines())
                        if VERBOSE:
                            print('Parsing', unit)
                        unit_path = '.'.join(unit.OR_path.split('.')[:-1])

                        # Patch field writing, e.g. UNIT = xxxx
                        reserve = re.findall(
                            r'^([\t \(]*)%s = (.*)' % unit.name, method_content, re.MULTILINE)
                        for item in reserve:
                            target = '%s%s = %s' % (
                                item[0], unit.name, item[1])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (%s + %s, %s, %s)' % (
                                        item[0], OR.WECB, unit.offset, OR.offset, unit.size, item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s' % unit.name
                                    method_content = self._method[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self._method[scope][method]['modified'] = True

                        # Patch field writing, e.g. Store (xxxx, UNIT)
                        reserve = re.findall(
                            'Store \\((\\w+), %s\\)' % unit.name, method_content)
                        for item in reserve:
                            target = 'Store (%s, %s)' % (
                                item, unit.name)
                            for line in it_lines:
                                if target in line:
                                    replace = '%s (%s + %s, %s, %s)' % (
                                        OR.WECB, unit.offset, OR.offset, unit.size, item)
                                    replace = line.replace(
                                        target, replace) + ' //%s' % unit.name
                                    method_content = self._method[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self._method[scope][method]['modified'] = True

                        # Patch field writing, e.g. ECWT (data, RefOf (UNIT)) to WECB(offset, size, data)
                        reserve = re.findall(
                            r'(.*)ECWT \((.*), RefOf \(%s\)\)(.*)' % unit.name, method_content)
                        for item in reserve:
                            target = '%sECWT (%s, RefOf (%s))%s' % (
                                item[0], item[1], unit.name, item[2])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (%s + %s, %s, %s)' % (
                                        item[0], OR.WECB, unit.offset, OR.offset, unit.size, item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s' % unit.name
                                    method_content = self._method[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self._method[scope][method]['modified'] = True

                        # Patch field reading, e.g. xxxx = ECRD (RefOf (UNIT)) to xxxx = RECB(offset, size)
                        reserve = re.findall(
                            r'(.*)ECRD \(RefOf \(%s\)\)(.*)' % unit.name, method_content)
                        for item in reserve:
                            target = '%sECRD (RefOf (%s))%s' % (
                                item[0], unit.name, item[1])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (%s + %s, %s)%s' % (
                                        item[0], OR.RECB, unit.offset, OR.offset, unit.size, item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s' % unit.name
                                    method_content = self._method[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self._method[scope][method]['modified'] = True

                        # Patch field reading, e.g. xxxx = UNIT
                        reserve = re.findall(
                            r'(^.*[^\.a-zA-Z/])%s([^a-zA-Z0-9,\.\n][^\(])' % unit.name, method_content, re.MULTILINE)
                        for item in reserve:
                            if 'Method (' in item[0] or 'Device (' in item[0] or 'Scope (' in item[0]:
                                continue  # stop patching method that have the same name as fieldunit
                            target = item[0] + unit.name + item[1]
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (%s + %s, %s)%s' % (
                                        item[0], OR.RECB, unit.offset, OR.offset, unit.size, item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s' % unit.name
                                    method_content = self._method[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self._method[scope][method]['modified'] = True

                        # Patch field writing, e.g. EC0.UNIT = xxxx
                        reserve = re.findall(
                            r'(.*%s\.)%s = (\\w+)' % (unit.OR_path.split('.')[-2], unit.name), method_content)
                        for item in reserve:
                            target = '%s%s = %s' % (
                                item[0], unit.name, item[1])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (%s + %s, %s, %s)' % (
                                        item[0], OR.WECB, unit.offset, OR.offset, unit.size, item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s.%s' % (unit_path, unit.name)
                                    method_content = self._method[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self._method[scope][method]['modified'] = True

                        # Patch field writing, e.g. Store (xxxx, EC0.UNIT)
                        reserve = re.findall(
                            'Store \\((\\w+), (.*%s.)%s\\)' % (
                                unit.OR_path.split('.')[-2], unit.name
                            ), method_content)
                        for item in reserve:
                            target = 'Store (%s, %s%s)' % (
                                item[0], item[1], unit.name)
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (%s + %s, %s, %s)' % (
                                        item[1], OR.WECB, unit.offset, OR.offset, unit.size, item[0])
                                    replace = line.replace(
                                        target, replace) + ' //%s.%s' % (unit_path, unit.name)
                                    method_content = self._method[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self._method[scope][method]['modified'] = True

                        # Patch field writing, e.g. ECWT (data, RefOf (EC0.UNIT)) to WECB(offset, size, data)
                        reserve = re.findall(
                            r'(.*)ECWT \((.*), RefOf \((.*%s\.)%s\)\)(.*)' % (
                                unit.OR_path.split('.')[-2], unit.name
                            ), method_content)
                        for item in reserve:
                            target = '%sECWT (%s, RefOf (%s%s))%s' % (
                                item[0], item[1], item[2], unit.name, item[3])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (%s + %s, %s, %s)' % (
                                        item[0], OR.WECB, unit.offset, OR.offset, unit.size, item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s.%s' % (unit_path, unit.name)
                                    method_content = self._method[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self._method[scope][method]['modified'] = True

                        # Patch field reading, e.g. xxxx = EC0.ECRD (RefOf (EC0.UNIT)) to xxxx = B1B2 (ECRD (RefOf (UNI0)), ECRD (RefOf (UNI1)))
                        reserve = re.findall(
                            r'(.*)ECRD \(RefOf \((.*%s\.)%s\)\)(.*)' % (
                                unit.OR_path.split('.')[-2], unit.name
                            ), method_content)
                        for item in reserve:
                            target = '%sECRD (RefOf (%s%s))%s' % (
                                item[0], item[1], unit.name, item[2])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (%s + %s, %s)%s' % (
                                        item[0], OR.RECB, unit.offset, OR.offset, unit.size, item[2])
                                    replace = line.replace(
                                        target, replace) + ' //%s.%s' % (unit_path, unit.name)
                                    method_content = self._method[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self._method[scope][method]['modified'] = True

                        # Patch field reading, e.g. xxxx = EC0.UNIT
                        reserve = re.findall(
                            r'(.*%s\.)%s([\) ]*)' % (unit.OR_path.split('.')[-2], unit.name), method_content)
                        for item in reserve:
                            target = item[0] + unit.name + item[1]
                            for line in it_lines:
                                if 'Method (' in item[0] or 'Device (' in item[0] or 'Scope (' in item[0]:
                                    continue  # stop patching method that have the same name as fieldunit
                                if target in line:
                                    replace = '%s%s (%s + %s, %s)%s' % (item[0], OR.RECB,
                                                                        unit.offset, OR.offset, unit.size, item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s.%s' % (unit_path, unit.name)
                                    method_content = self._method[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self._method[scope][method]['modified'] = True

    def _patch_dual_battery(self):
        # TODO: Multiple battery
        content = []
        try:
            content += self.gc.search('Notify\s\(BAT[0123]', regex=True)
            for EC in self._PNP0C09:
                a = 'Notify\s\(%s\.%s\.BAT[0123]' % (EC.scope.replace('\\', '\\\\').replace('.', '\.'), EC.name)
                content += self.gc.search(a, regex=True)
                a = a.replace('\\\\', '')
                content += self.gc.search(a, regex=True)
        except RuntimeError:
            pass
        for item in content:
            item.content = re.sub('Notify\s\(BAT[0123]', 'Notify (BATC', item.content)
            for EC in self._PNP0C09:
                a = r'Notify\s\(%s\.%s\.BAT[0123]' % (EC.scope.replace('\\', '\\\\').replace('.', r'\.'), EC.name)
                b = 'Notify (%s.%s.BATC' % (EC.scope, EC.name)
                item.content = re.sub(a, b, item.content)
                a = a.replace('\\\\', '')
                item.content = re.sub(a, b, item.content)
            item.content = re.sub(r'Notify\s\(\^BAT[0123]', 'Notify (^BATC', item.content)
            item.content = re.sub(r'Notify\s\(\^\^BAT[0123]', 'Notify (^^BATC', item.content)

            if item.scope not in self._method:
                self._method[item.scope] = {item.name: {'content': item.content, 'modified': True}}
            else:
                self._method[item.scope][item.name] = {'content': item.content, 'modified': True}

    def _patch_PTSWAK(self):
        '''
        Patch _PTS and _WAK if they are modified.
        '''
        is_PTS_Serialized = 'NotSerialized'
        is_WAK_Serialized = 'NotSerialized'
        is_TTS_Serialized = 'NotSerialized'
        for scope in self._method.copy():
            for method in self._method[scope].copy():
                if not self._method[scope][method]['modified']:
                    # skip unmodified method
                    continue
                if '_PTS' in method:
                    self._method[scope]['_PTS'] = {'content': self._method[scope][method]['content'].replace(
                        '_PTS', 'YPTS'), 'modified': True}

                if '\\_PTS' in method:
                    self._method[scope]['\\_PTS'] = {'content': self._method[scope][method]['content'].replace(
                        '_PTS', 'YPTS'), 'modified': True}

                if '_WAK' in method:
                    self._method[scope]['_WAK'] = {'content': self._method[scope][method]['content'].replace(
                        '_WAK', 'YWAK'), 'modified': True}

                if '\\_WAK' in method:
                    self._method[scope]['\\_WAK'] = {'content': self._method[scope][method]['content'].replace(
                        '_WAK', 'YWAK'), 'modified': True}

                if '_TTS' in method:
                    self._method[scope]['_WAK'] = {'content': self._method[scope][method]['content'].replace(
                        '_WAK', 'YWAK'), 'modified': True}

                if '\\_TTS' in method:
                    self._method[scope]['\\_WAK'] = {'content': self._method[scope][method]['content'].replace(
                        '_WAK', 'YWAK'), 'modified': True}

                if '_PTS' in method or '_WAK' in method or '_TTS' in method:
                    try:
                        is_PTS_Serialized = re.search(
                            '_PTS, 1, (NotSerialized|Serialized)', self._dsdt_content).groups()[0]
                    except AttributeError:
                        is_PTS_Serialized = None
                    try:
                        is_WAK_Serialized = re.search(
                            '_WAK, 1, (NotSerialized|Serialized)', self._dsdt_content).groups()[0]
                    except AttributeError:
                        is_WAK_Serialized = None
                    try:
                        is_TTS_Serialized = re.search(
                            '_TTS, 1, (NotSerialized|Serialized)', self._dsdt_content).groups()[0]
                    except AttributeError:
                        is_TTS_Serialized = None

                    if is_PTS_Serialized or is_WAK_Serialized or is_TTS_Serialized:
                        self._method['\\_SB'] = {'\\_SB.PCI9': {
                            'content': PCI9, 'modified': True}}

                    if is_PTS_Serialized:
                        _PTS = PTS[0] + is_PTS_Serialized + PTS[1]
                        if '\\_PTS' in self._method['\\']:
                            self._method['\\']['\\_PTS']['content'] += _PTS
                            self._method['\\']['\\_PTS']['modified'] = True
                        else:
                            self._method['\\']['\\_PTS'] = {
                                'content': _PTS, 'modified': True}

                    if is_WAK_Serialized:
                        _WAK = WAK[0] + is_WAK_Serialized + WAK[1]
                        if '\\_WAK' in self._method['\\']:
                            self._method['\\']['\\_WAK']['content'] += _WAK
                            self._method['\\']['\\_WAK']['modified'] = True
                        else:
                            self._method['\\']['\\_WAK'] = {
                                'content': _WAK, 'modified': True}

                    if is_TTS_Serialized:
                        _TTS = TTS[0] + is_TTS_Serialized + TTS[1]
                        if '\\_TTS' in self._method['\\']:
                            self._method['\\']['\\_TTS']['content'] += _TTS
                            self._method['\\']['\\_TTS']['modified'] = True
                        else:
                            self._method['\\']['\\_TTS'] = {
                                'content': _TTS, 'modified': True}

    def _insert_osi(self):
        '''
        Insert 'If (_OSI ('Darwin'))' into each method to avoid affacting Windows which is booted with OpenCore.
        '''
        for scope in self._method:
            for method in self._method[scope]:
                if not self._method[scope][method]['modified']:
                    # skip unmodified method
                    continue
                if "Darwin" in self._method[scope][method]['content']:
                    continue
                stack = []
                method_info = re.search(
                    'Method \((\\\?[\w\.]+), (\d+), (NotSerialized|Serialized)\)',
                    self._method[scope][method]['content']).groups()

                # Insert if _OSI at the beginning
                self._method[scope][method]['content'] = self._method[scope][method]['content'].replace(
                    'Method (%s, %s, %s)' % (
                        method_info[0], method_info[1], method_info[2]),
                    'Method (%s, %s, %s) \n{ \nIf (_OSI (\"Darwin\"))' % (
                        method_info[0], method_info[1], method_info[2]),
                )
                for index in range(0, len(self._method[scope][method]['content'])):
                    if '{' in self._method[scope][method]['content'][index]:
                        stack.append('{')
                    if '}' in self._method[scope][method]['content'][index]:
                        stack.pop()
                        if len(stack) == 1:
                            arg = ''
                            for i in range(0, int(method_info[1])):
                                if i > 0:
                                    arg += ', '
                                arg += 'Arg%d' % i
                            # Insert return original method at the bottom
                            self._method[scope][method]['content'] = self._method[scope][method]['content'][:index] + \
                                '}\n        Else\n        {\n            Return(X%s(%s))\n        }\n' % (
                                method_info[0][-3:], arg) + \
                                self._method[scope][method]['content'][index:]
                            break

    def _special_devices(self):
        '''
        This method automatically patch some special laptops. For example, some HP laptop have ACEL device,
        which will cause battery info not able to be updated.
        '''

        def __patch_ACEL__(self):
            '''
            Disable HP laptops' ACEL device
            '''
            print('Patching ACEL...')
            content = self.gc.search(
                r'\^\^LPCB\.EC0\.SMWR\s\(0xC6,\s0x50,\s0x22,\s0x40\)\s*\^\^LPCB\.EC0\.SMWR\s\(0xC6,\s0x50,\s0x36,\sOne\)',
                'Method', regex=True)
            for item in content:
                path = item.scope
                if path not in self._method:
                    self._method[path] = {}
                self._method[path]['%s.ADJT' % path] = {
                    'content': ADJT,
                    'modified': True
                }

        if 'Device (ACEL)' in self._dsdt_content and 'Method (ADJT' in self._dsdt_content:
            if 'HPQOEM' not in self._dsdt_content:
                print(IS_THIS_HP_LAPTOP)
                inp = input()
                if inp == 'yes' or inp == 'y':
                    __patch_ACEL__(self)
            else:
                __patch_ACEL__(self)

    def _generate_comment(self):
        # Find mutex and set them to zero
        self._patch_list = []
        mutex = re.findall(r'Mutex \((.*?), (.*?)\)', self._dsdt_content)
        for item in mutex:
            patch = {}
            name = item[0]
            value = int(item[1], 16)
            find = replace = '01'
            if value != 0:
                for c in name:
                    asc = ord(c)
                    find += '%02X' % asc
                    replace += '%02X' % asc
                find += '%02X' % value
                replace += '00'
                patch['comment'] = '[BATT] Set mutex %s to zero' % name
                patch['find'] = find
                patch['replace'] = replace
                self._patch_list.append(patch)

        # generate ACPI patch
        for scope in self._method:
            for method in self._method[scope]:
                if not self._method[scope][method]['modified']:
                    # Skip unmodified method
                    continue
                patch = {}
                method_name = re.split(r'[\.\\]', method)[-1]
                try:
                    method_info = list(re.search(r'Method \((%s), (\d+?), (Serialized|NotSerialized)\)' % method_name,
                                                 self._method[scope][method]['content']).groups())
                except AttributeError:
                    continue
                method_info[0] = method_info[0].replace('\\', '')
                if method_info[0] in dangerous_patch_list:
                    # Warning user if this tool patched some dangerous methods
                    print(DANGEROUS_PATCH_MSG[0], method_info[0], DANGEROUS_PATCH_MSG[1],
                          'X%s' % method_info[0][1:], DANGEROUS_PATCH_MSG[2])
                method_info[1] = int(method_info[1])
                if method_info[2] == 'Serialized':
                    method_info[1] += 8
                find = replace = ''
                for c in method_info[0]:
                    asc = ord(c)
                    find += '%02X' % asc
                    replace += '%02X' % asc
                replace = '58' + replace[2:]  # Set the 1st character to 'X'
                find += '%02X' % method_info[1]
                replace += '%02X' % method_info[1]
                patch['comment'] = '[BATT] Rename %s to X%s' % (
                    method_info[0], method_info[0][1:])
                patch['find'] = find
                patch['replace'] = replace
                self._patch_list.append(patch)

        # Add comment before dsl file
        self._comment += '/*\n'
        self._comment += '* This battery hot patch is generate by SSDT-BATT_Auto_Gen, \n'
        self._comment += '* which is a python program written by Eric Kwok.\n'
        self._comment += '*\n'
        self._comment += '* Note: Should be compile with -f option.\n'
        self._comment += '* For any support, plese visit https://github.com/the-eric-kwok/SSDT-BATT_Auto_Gen/issues\n'
        self._comment += '*\n'
        self._comment += '* Patched unit: \n'
        for OR in self._OR_info:
            self._comment += '* '
            for unit in OR.field_units:
                self._comment += '%s ' % unit.name
            self._comment += '\n'
        self._comment += '*\n'
        for patch in self._patch_list:
            self._comment += '* %s\n' % patch['comment']
            self._comment += '* Find:    %s\n' % patch['find']
            self._comment += '* Replace: %s\n' % patch['replace']
            self._comment += '*\n'
        self._comment += '*/\n'

    def _assemble(self, DUAL_BATT):
        '''
        Grab comments, head, body, tail, and assemble them together.
        '''
        self._file_generated = self._comment
        self._file_generated += (self._head + self._RW_method)
        for scope in self._method:
            for method in self._method[scope]:
                if not self._method[scope][method]:
                    break
            else:
                self._file_generated += '    Scope (%s)\n    {\n' % scope
                for method in self._method[scope]:
                    if not self._method[scope][method]['modified']:
                        # Skip unmodified method
                        continue
                    self._file_generated += self._method[scope][method]['content'] + '\n'
                self._file_generated += '    }\n'
            # Skip empty scope
            continue
        if DUAL_BATT:
            self._file_generated += SSDT_BATC[0] + self._PNP0C0A[0].scope + SSDT_BATC[1]
        self._file_generated += '}\n'

    def _re_indent(self):
        stack = []
        splited = self._file_generated.split('\n')
        # Parse line by line
        for index in range(0, len(splited)):
            # Delete space at front of each line
            splited[index] = splited[index].strip()
            count = splited[index].count('{')
            count -= splited[index].count('}')
            if count < 0:
                for i in range(0, -count):
                    stack.pop()
            # Indent by brackets
            splited[index] = '    ' * len(stack) + splited[index]
            if count > 0:
                for i in range(0, count):
                    stack.append('{')

        self._file_generated = '\n'.join(splited)

    def _write_file(self):
        '''
        Write to dsl file, and also try to compile it automatically.
        '''
        out_path = []
        out_path.append(os.path.expanduser('~') + os.sep +
                        'Desktop' + os.sep + 'Battery_hotpatch')
        # Replace DSDT with SSDT-BATT and fill it in filename
        out_path.append(os.path.split(
            self._filepath.replace('DSDT', 'SSDT-BATT'))[1])
        # Replace dsdt with SSDT-BATT in filename
        out_path[1] = out_path[1].replace('dsdt', 'SSDT-BATT')

        if not os.path.exists(out_path[0]):
            # If directory not exists
            os.makedirs(out_path[0])

        out_file = os.sep.join(out_path)
        out_path = out_path[0]
        try:
            with open(out_file, 'x') as f:
                f.write(self._file_generated)
                print(GENERATE_SUCCESSFUL_MSG)
        except FileExistsError:
            for i in range(1, 100):
                test = '.'.join(out_file.split('.')[:-1]) + '_%d.dsl' % i
                try:
                    with open(test, 'x') as f:
                        f.write(self._file_generated)
                        out_file = test
                        print(GENERATE_SUCCESSFUL_MSG)
                    break
                except FileExistsError:
                    pass

        if os.path.exists('./iasl') and os.sys.platform == 'darwin':
            with os.popen('./iasl -va -f %s 2>&1' % out_file) as p:
                ret = p.read()
                if 'AML Output' in ret:
                    ret_spl = ret.splitlines()
                    for line in ret_spl:
                        if line.startswith('AML Output'):
                            if ' 0 bytes' not in line:
                                print(COMPILE_SUCCESS_MSG)
                                break
                            else:
                                print(COMPILE_FAILED_ERR)
                                print(ret)
                else:
                    print(COMPILE_FAILED_ERR)
        elif os.path.exists('.\\iasl.exe') and os.sys.platform == 'win32':
            with os.popen('.\\iasl.exe -va -f %s' % out_file) as p:
                ret = p.read()
                if 'AML Output' in ret:
                    ret_spl = ret.splitlines()
                    for line in ret_spl:
                        if line.startswith('AML Output'):
                            if '0 bytes' not in line:
                                print(COMPILE_SUCCESS_MSG)
                                break
                            else:
                                print(COMPILE_FAILED_ERR)
                                print(ret)
                else:
                    print(COMPILE_FAILED_ERR)
        else:
            print(TRY_TO_COMPILE_ANYWAY)
            os.system('iasl -va -f %s' % out_file)

        if os.sys.platform == 'darwin':
            os.system('open ' + out_path)
        elif os.sys.platform == 'win32':
            os.system('start ' + out_path)


def opener(filepath: str):
    try:
        with open(filepath, 'r') as f:
            content = f.read()
            return content
    except UnicodeDecodeError:
        with open(filepath, 'rb') as fb:
            rawdata = fb.read()
            for encoding in ('ascii', 'utf8', 'gbk', 'latin1'):
                try:
                    content = rawdata.decode(encoding)
                    return content
                except UnicodeDecodeError:
                    pass
            try:
                content
            except NameError:
                if __CHARDET__:
                    guessing = chardet.detect(rawdata)
                    if guessing['confidence'] > 0.5:
                        content = rawdata.decode(guessing['encoding'])
                        return content
                raise RuntimeError('File encoding not known')
    except FileNotFoundError:
        print(FILE_NOT_FOUND_ERR)
        exit(1)
    except PermissionError:
        print(PERMISSION_ERR)
        exit(1)


def show_help():
    print(HELP_MESSAGE)
    exit()


def parse_args():
    '''
    Parsing arguments and load file contents

    @return: (filename, filepath, dsdt_content) - tuple(str)
    '''
    global VERBOSE, DEBUG, FORCE
    filename = filepath = dsdt_content = None
    arg_lens = len(sys.argv)
    if arg_lens == 1:
        show_help()
    for arg in sys.argv:
        if '-h' in arg or 'help' in arg:
            show_help()
        if '-v' in arg:
            VERBOSE = True
            gc.set_verbose(True)
        if '-F' in arg or '--force' in arg:
            FORCE = True
        if '-debug' in arg:
            VERBOSE = True
            DEBUG = True
            gc.set_debug(True)
        if '.dsl' in arg:
            filename = arg
            filepath = os.path.abspath(filename)
            dsdt_content = opener(filepath=filepath)
        if '.aml' in arg or '.dat' in arg:
            if os.path.exists('./iasl') and os.sys.platform == 'darwin':
                # print('file: '+arg)
                with os.popen("./iasl -d ' % s' 2>&1" % arg) as p:
                    ret = p.read()
                    if 'ASL Output' in ret:
                        print(DECOMPILE_SUCCESS_MSG)
                    else:
                        print(ret)
                        exit(1)
            elif os.path.exists('.\\iasl.exe') and os.sys.platform == 'win32':
                # print('file: '+arg)
                with os.popen(".\\iasl.exe -d ' % s' 2>&1" % arg) as p:
                    ret = p.read()
                    if 'ASL Output' in ret:
                        print(DECOMPILE_SUCCESS_MSG)
                    else:
                        print(ret)
                        exit(1)
            else:
                print(NO_IASL_COMPILER)
                exit(1)
            filename = arg.replace('.aml', '.dsl')
            filepath = os.path.abspath(filename)
            dsdt_content = opener(filepath=filepath)
    if filepath and dsdt_content:
        return (filepath, dsdt_content)
    else:
        show_help()


if __name__ == '__main__':
    start_time = time.time()
    filepath, __dsdt_content__ = parse_args()

    result = re.findall('PNP0C0A', __dsdt_content__)
    if len(result) < 1:
        print(TOO_FEW_BATT_ERR)
        exit(1)

    # Single battery device
    app = AutoGen(__dsdt_content__, filepath)
    # if VERBOSE:
    print('程序执行用时', time.time() - start_time, '秒')
