#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from os import replace
import random
import sys
import os
import re
from multilanguage import *
import time
import get_content_rewrite
from cons_strings import *
import copy

# Third party libraies
try:
    import chardet
    __CHARDET__ = True
except ImportError:
    __CHARDET__ = False

dangerous_patch_list = ['_STA', '_CRS', '_REG', '_ADR', '_PRW', '_DCS', '_DGS', '_DSS', '_INI', '_PS0', '_PS1',
                        '_PS2', '_PS3', '_PS4', '_PS5', '_S0D', '_S1D', '_S2D', '_S3D', '_S4D', '_S5D']
VERBOSE = False
DEBUG = False
FORCE = False


class AutoGen:
    __OR_info__ = list()
    __PNP0C09__ = list()
    __PNP0C0A__ = list()
    __head__ = HEAD
    __RW_method__ = ''
    __comment__ = ''
    __dsdt_content__ = ''
    __file_generated__ = ''
    __filepath__ = ''
    __method__ = dict()

    def __init__(self, __dsdt_content__: str, __filepath__: str) -> None:
        self.__dsdt_content__ = __dsdt_content__
        self.__filepath__ = __filepath__
        self.__clean_out__()
        self.gc = get_content_rewrite.GetContent(self.__dsdt_content__)
        EC = self.gc.search('PNP0C09')
        self.__PNP0C09__ = []
        for item in EC:
            EC_path = item['scope'] + '.' + item['name']  # TODO Multiple EC support (Should just work)
            self.__PNP0C09__ += self.gc.get_content(EC_path)
        self.__find_OperationRegion__()
        self.__find_field__()
        self.__patch_method__()
        self.__PNP0C0A__ = self.gc.search('PNP0C0A', 'Device')
        for item in self.__PNP0C0A__.copy():
            a = re.findall('Method\s\(_STA,\s0,\sNotSerialized\)\s*\{\s*Return\s\(Zero\)\s*\}', item['content'])
            if len(a) > 0:
                self.__PNP0C0A__.remove(item)
        if len(self.__PNP0C0A__) > 1:
            DUAL_BATT = True
            self.__patch_dual_battery__()
        else:
            DUAL_BATT = False
        self.__patch_PTSWAK__()
        self.__insert_osi__()
        self.__special_devices__()
        self.__generate_comment__()
        self.__assemble__(DUAL_BATT)
        self.__re_indent__()
        self.__write_file__()

    def __clean_out__(self):
        '''
        Removes comments, external, Firmware error generated by iasl, etc.
        '''
        # Remove block comments
        self.__dsdt_content__ = re.sub(
            r'/\*[\w\W\n]*?\*/', '', self.__dsdt_content__)
        # Remove line comments
        self.__dsdt_content__ = re.sub(r'//.*', '', self.__dsdt_content__)
        # Remove 'External' declaration
        self.__dsdt_content__ = re.sub(
            r'External.*\n', '', self.__dsdt_content__)
        # Remove 'Firmware Error' that generated within disassambling
        self.__dsdt_content__ = re.sub(
            r'Firmware Error.*\n', '', self.__dsdt_content__)
        # Remove empty lines
        self.__dsdt_content__ = re.sub(r'^\n', '', self.__dsdt_content__)

    def __find_OperationRegion__(self):
        '''
        Finding OperationRegion(s) inside EC scope.
        '''
        if VERBOSE:
            print(
                'Into: find_OperationRegion(): Finding OperationRegion(s) inside EC scope.')
        for EC in self.__PNP0C09__.copy():
            OR_list = re.findall(
                'OperationRegion\s\((.*?),\s.*?,\s(.*?),\s.*?\)', EC['content'])
            for OR_name in OR_list.copy():
                content = self.gc.get_content(OR_name[0], 'OperationRegion')
                for item in content.copy():
                    if 'EC' in item['scope']:  # Remove contents that is not in EC
                        break
                    content.remove(item)
                if len(content) == 0:
                    OR_list.remove(OR_name)
                    break
                for item in content:
                    OR_info = re.search(  # Getting info of OperationRegions by re.group
                        'OperationRegion\s\(%s,\s([a-zA-Z].*),\s%s,\s([a-zA-Z0-9].*)\)' % OR_name, item['content'])
                    try:
                        if OR_name[1] == 'Zero':
                            offset = 0
                        elif OR_name[1] == 'One':
                            offset = 1
                        elif 'Arg' in OR_name[1]:
                            continue  # TODO 处理类似 OperationRegion (NAME, Memory, Arg0, 0x01) 的情况
                        elif '0x' in OR_name[1]:
                            offset = int(OR_name[1], 16)
                        else:
                            # TODO 处理类似 OperationRegion (ECAD, SystemMemory, GNBF, 0x10) 的情况，GNBF是另一个Unit (FX503VD)
                            offset = OR_name[1]
                        self.__OR_info__.append({
                            'scope': item['scope'],
                            'name': OR_name[0],
                            'storage': OR_info.group(1),
                            'offset': offset,
                            'length': OR_info.group(2)
                        })
                    except AttributeError:
                        continue
        if VERBOSE:
            for item in self.__OR_info__:
                print(item)
            print()

    def __find_field__(self):
        '''
        Finding out which unit field is going to be patched inside EC scope.
        '''
        if VERBOSE:
            print(
                'Into: find_field(): Finding out which unit field is going to be patched inside EC scope.')
        for OR in self.__OR_info__:
            OR['field_unit'] = []
            OR_path = OR['scope'] + '.' + OR['name']
            blocks = self.gc.get_content(OR_path)
            content = ''
            for block in blocks:
                content += block['content'] + '\n'
            # for block in blocks:
            for field in content.split('}')[:-1]:
                field = field.split('{')[1]  # Remove field header
                store_flag = False  # Is there any field that larger than 16 bits in this method?
                field_content_splln = field.split('\n')
                offset_bits = 0  # offset in bits
                name = ''
                size = 0
                for item in field_content_splln:
                    if ',' not in item:
                        # Skip empty line
                        continue
                    elif 'Offset' not in item:
                        # Parse line such as `ABCD, 8,`
                        item_spl = item.split(',')
                        name = item_spl[0].strip()
                        size = int(item_spl[1].strip())
                        if size > 8 and name != '':
                            if offset_bits/8 - int(offset_bits/8) != 0:
                                print(FIELD_UNIT_OFFSET_ERR)
                                exit(2)
                            OR['field_unit'].append(
                                {'name': name, 'offset': int(offset_bits/8), 'size': size, 'OR_path': OR_path})
                            store_flag = True
                        offset_bits += size
                    else:
                        # Parse line such as `Offset (0x64),`
                        item = item.strip()
                        offset = re.search(r'Offset \((.*)\)', item).group(1)
                        offset_bits = int(offset, 16) * 8

                if store_flag:
                    # Store this OperationRegion and its units
                    if OR['storage'] not in self.__RW_method__:
                        while True:
                            # This will generate a new R/W method name
                            letter = random.choice(
                                '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ')
                            OR['RE1B'] = 'R1B' + letter
                            OR['RECB'] = 'REB' + letter
                            OR['ERM2'] = 'MEM' + letter
                            OR['WE1B'] = 'W1B' + letter
                            OR['WECB'] = 'WRB' + letter
                            if (self.__dsdt_content__.find(OR['RE1B']) == -1 and OR['RE1B'] not in self.__RW_method__) \
                                    and (self.__dsdt_content__.find(OR['RECB']) == -1 and OR['RECB'] not in self.__RW_method__) \
                                    and (self.__dsdt_content__.find(OR['ERM2']) == -1 and OR['ERM2'] not in self.__RW_method__) \
                                    and (self.__dsdt_content__.find(OR['WE1B']) == -1 and OR['WE1B'] not in self.__RW_method__) \
                                    and (self.__dsdt_content__.find(OR['WECB']) == -1 and OR['WECB'] not in self.__RW_method__):
                                # Loop until there is nothing has the same name as our generated one
                                break

                        # Add the content of R/W method to self.RW_method
                        self.__RW_method__ += RW_METHOD[0] + \
                                              OR['scope'] + RW_METHOD[1] + \
                                              OR['RE1B'] + RW_METHOD[2] + \
                                              OR['ERM2'] + RW_METHOD[3] + \
                                              OR['storage'] + RW_METHOD[4] + \
                                              OR['ERM2'] + RW_METHOD[5] + \
                                              OR['RECB'] + RW_METHOD[6] + \
                                              OR['RE1B'] + RW_METHOD[7] + \
                                              OR['WE1B'] + RW_METHOD[8] + \
                                              OR['ERM2'] + RW_METHOD[9] + \
                                              OR['storage'] + RW_METHOD[10] + \
                                              OR['ERM2'] + RW_METHOD[11] + \
                                              OR['WECB'] + RW_METHOD[12] + \
                                              OR['WE1B'] + RW_METHOD[13]
                    else:
                        # If OR['storage'] in self.RW_method and not in OR itself
                        # Then copy the read/write method from other OR which has the same storage
                        for _OR_ in self.__OR_info__:
                            try:
                                _OR_['RE1B']
                            except KeyError:
                                continue
                            if _OR_['storage'] == OR['storage']:
                                OR['RE1B'] = _OR_['RE1B']
                                OR['RECB'] = _OR_['RECB']
                                OR['ERM2'] = _OR_['ERM2']
                                OR['WE1B'] = _OR_['WE1B']
                                OR['WECB'] = _OR_['WECB']
                                break

        for OR in self.__OR_info__:
            if len(OR['field_unit']) < 1:
                self.__OR_info__.remove(OR)

        if 'RECB' not in self.__RW_method__:
            print(NOT_NEED_TO_PATCH_MSG)
            exit(0)

        if VERBOSE:
            for OR in self.__OR_info__:
                print(OR['scope'] + '.' + OR['name'] + ', ' + OR['storage'])
                for unit in OR['field_unit']:
                    print('  -', unit)

    def __patch_method__(self):
        '''
        Getting method content by unit fields which is going to be patched. And patch each method returned.
        '''
        if VERBOSE:
            print('\nInto: patch_method().')
        for OR in self.__OR_info__:
            # Getting method content
            for unit in OR['field_unit']:
                try:
                    result = self.gc.search(unit['name'], 'Method')
                except RuntimeError:
                    continue
                for block in result:
                    # if result[name].split()[0] != 'Method':
                    # Ignore content which is not Method
                    # continue
                    scope = block['scope']
                    method = block['name']
                    if scope == '' or method.startswith('\\'):
                        # Handle method like 'Method (\WAK)'
                        scope = '\\'
                    try:
                        if block['scope'] in self.__method__[scope] or ('EC' not in block['scope'] and 'EC' not in block['content']):
                            # remove duplicates, and remove fieldunit that not in EC scope
                            continue
                    except KeyError:
                        if 'EC' not in block['scope'] and 'EC' not in block['content']:
                            # Remove fieldunit that not in EC scope
                            continue
                    if scope not in self.__method__:
                        self.__method__[scope] = {}
                    self.__method__[scope][block['name']] = {
                        'content': block['content'], 'modified': False}

            # Patching method
            for scope in self.__method__:
                for method in self.__method__[scope]:
                    method_content = self.__method__[scope][method]['content']
                    if VERBOSE:
                        print('\n%s\n| Patching: %s |\n%s' % (
                            '='*(14+len(method)), method, '='*(14+len(method))))
                        if 'GCMD' in method:
                            print('trigger')
                    for unit in OR['field_unit']:
                        it_lines = iter(method_content.splitlines())
                        if VERBOSE:
                            print('Parsing', unit)
                        unit_path = '.'.join(unit['OR_path'].split('.')[:-1])

                        # Patch field writing, e.g. UNIT = xxxx
                        reserve = re.findall(
                            '([\t \(]*)%s = (.*)' % unit['name'], method_content)
                        for item in reserve:
                            target = '%s%s = %s' % (
                                item[0], unit['name'], item[1])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (0x%X, %s, %s)' % (
                                        item[0], OR['WECB'], unit['offset'] + OR['offset'], unit['size'], item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s' % unit['name']
                                    method_content = self.__method__[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self.__method__[scope][method]['modified'] = True

                        # Patch field writing, e.g. Store (xxxx, UNIT)
                        reserve = re.findall(
                            'Store \\((\\w+), %s\\)' % unit['name'], method_content)
                        for item in reserve:
                            target = 'Store (%s, %s)' % (
                                item, unit['name'])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s (0x%X, %s, %s)' % (
                                        OR['WECB'], unit['offset'] + OR['offset'], unit['size'], item)
                                    replace = line.replace(
                                        target, replace) + ' //%s' % unit['name']
                                    method_content = self.__method__[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self.__method__[scope][method]['modified'] = True

                        # Patch field writing, e.g. ECWT (data, RefOf (UNIT)) to WECB(offset, size, data)
                        reserve = re.findall(
                            '(.*)ECWT \((.*), RefOf \(%s\)\)(.*)' % unit['name'], method_content)
                        for item in reserve:
                            target = '%sECWT (%s, RefOf (%s))%s' % (
                                item[0], item[1], unit['name'], item[2])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (0x%X, %s, %s)' % (
                                        item[0], OR['WECB'], unit['offset'] + OR['offset'], unit['size'], item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s' % unit['name']
                                    method_content = self.__method__[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self.__method__[scope][method]['modified'] = True

                        # Patch field reading, e.g. xxxx = ECRD (RefOf (UNIT)) to xxxx = RECB(offset, size)
                        reserve = re.findall(
                            '(.*)ECRD \(RefOf \(%s\)\)(.*)' % unit['name'], method_content)
                        for item in reserve:
                            target = '%sECRD (RefOf (%s))%s' % (
                                item[0], unit['name'], item[1])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (0x%X, %s)%s' % (
                                        item[0], OR['RECB'], unit['offset'] + OR['offset'], unit['size'], item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s' % unit['name']
                                    method_content = self.__method__[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self.__method__[scope][method]['modified'] = True

                        # Patch field reading, e.g. xxxx = UNIT
                        reserve = re.findall(
                            '(^.*[^\.a-zA-Z/])%s([^a-zA-Z0-9,\.\n])' % unit['name'], method_content, re.MULTILINE)
                        for item in reserve:
                            if 'Method (' in item[0] or 'Device (' in item[0] or 'Scope (' in item[0]:
                                continue  # stop patching method that have the same name as fieldunit
                            target = item[0] + unit['name'] + item[1]
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (0x%X, %s)%s' % (
                                        item[0], OR['RECB'], unit['offset'] + OR['offset'], unit['size'], item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s' % unit['name']
                                    method_content = self.__method__[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self.__method__[scope][method]['modified'] = True

                        # Patch field writing, e.g. EC0.UNIT = xxxx
                        reserve = re.findall(
                            '(.*%s\.)%s = (\\w+)' % (unit['OR_path'].split('.')[-2], unit['name']), method_content)
                        for item in reserve:
                            target = '%s%s = %s' % (
                                item[0], unit['name'], item[1])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (0x%X, %s, %s)' % (
                                        item[0], OR['WECB'], unit['offset'] + OR['offset'], unit['size'], item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s.%s' % (unit_path, unit['name'])
                                    method_content = self.__method__[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self.__method__[scope][method]['modified'] = True

                        # Patch field writing, e.g. Store (xxxx, EC0.UNIT)
                        reserve = re.findall(
                            'Store \\((\\w+), (.*%s.)%s\\)' % (
                                unit['OR_path'].split('.')[-2], unit['name']
                            ), method_content)
                        for item in reserve:
                            target = 'Store (%s, %s%s)' % (
                                item[0], item[1], unit['name'])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (0x%X, %s, %s)' % (
                                        item[1], OR['WECB'], unit['offset'] + OR['offset'], unit['size'], item[0])
                                    replace = line.replace(
                                        target, replace) + ' //%s.%s' % (unit_path, unit['name'])
                                    method_content = self.__method__[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self.__method__[scope][method]['modified'] = True

                        # Patch field writing, e.g. ECWT (data, RefOf (EC0.UNIT)) to WECB(offset, size, data)
                        reserve = re.findall(
                            '(.*)ECWT \((.*), RefOf \((.*%s\.)%s\)\)(.*)' % (
                                unit['OR_path'].split('.')[-2], unit['name']
                            ), method_content)
                        for item in reserve:
                            target = '%sECWT (%s, RefOf (%s%s))%s' % (
                                item[0], item[1], item[2], unit['name'], item[3])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (0x%X, %s, %s)' % (
                                        item[0], OR['WECB'], unit['offset'] + OR['offset'], unit['size'], item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s.%s' % (unit_path, unit['name'])
                                    method_content = self.__method__[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self.__method__[scope][method]['modified'] = True

                        # Patch field reading, e.g. xxxx = EC0.ECRD (RefOf (EC0.UNIT)) to xxxx = B1B2 (ECRD (RefOf (UNI0)), ECRD (RefOf (UNI1)))
                        reserve = re.findall(
                            '(.*)ECRD \(RefOf \((.*%s\.)%s\)\)(.*)' % (
                                unit['OR_path'].split('.')[-2], unit['name']
                            ), method_content)
                        for item in reserve:
                            target = '%sECRD (RefOf (%s%s))%s' % (
                                item[0], item[1], unit['name'], item[2])
                            for line in it_lines:
                                if target in line:
                                    replace = '%s%s (0x%X, %s)%s' % (
                                        item[0], OR['RECB'], unit['offset'] + OR['offset'], unit['size'], item[2])
                                    replace = line.replace(
                                        target, replace) + ' //%s.%s' % (unit_path, unit['name'])
                                    method_content = self.__method__[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self.__method__[scope][method]['modified'] = True

                        # Patch field reading, e.g. xxxx = EC0.UNIT
                        reserve = re.findall(
                            '(.*%s\.)%s([\) ]*)' % (
                                unit['OR_path'].split('.')[-2], unit['name']
                            ), method_content)
                        for item in reserve:
                            target = item[0] + unit['name'] + item[1]
                            for line in it_lines:
                                if 'Method (' in item[0] or 'Device (' in item[0] or 'Scope (' in item[0]:
                                    continue  # stop patching method that have the same name as fieldunit
                                if target in line:
                                    replace = '%s%s (0x%X, %s)%s' % (item[0], OR['RECB'],
                                                                     unit['offset'] + OR['offset'], unit['size'], item[1])
                                    replace = line.replace(
                                        target, replace) + ' //%s.%s' % (unit_path, unit['name'])
                                    method_content = self.__method__[scope][method]['content'] = method_content.replace(
                                        line, replace)
                                    break
                            self.__method__[scope][method]['modified'] = True

    def __patch_dual_battery__(self):
        # TODO: Multiple battery
        content = []
        try:
            content += self.gc.search('Notify\s\(BAT[0123]', regex=True)
            for EC in self.__PNP0C09__:
                a = 'Notify\s\(%s\.%s\.BAT[0123]' % (EC['scope'].replace('\\', '\\\\').replace('.', '\.'), EC['name'])
                content += self.gc.search(a, regex=True)
                a = a.replace('\\\\', '')
                content += self.gc.search(a, regex=True)
        except RuntimeError:
            pass
        for item in content:
            item['content'] = re.sub('Notify\s\(BAT[0123]', 'Notify (BATC', item['content'])
            for EC in self.__PNP0C09__:
                a = 'Notify\s\(%s\.%s\.BAT[0123]' % (EC['scope'].replace('\\', '\\\\').replace('.', '\.'), EC['name'])
                b = 'Notify (%s.%s.BATC' % (EC['scope'], EC['name'])
                item['content'] = re.sub(a, b, item['content'])
                a = a.replace('\\\\', '')
                item['content'] = re.sub(a, b, item['content'])
            item['content'] = re.sub('Notify\s\(\^BAT[0123]', 'Notify (^BATC', item['content'])
            item['content'] = re.sub('Notify\s\(\^\^BAT[0123]', 'Notify (^^BATC', item['content'])

            if item['scope'] not in self.__method__:
                self.__method__[item['scope']] = {item['name']: {'content': item['content'], 'modified': True}}
            else:
                self.__method__[item['scope']][item['name']] = {'content': item['content'], 'modified': True}

    def __patch_PTSWAK__(self):
        '''
        Patch _PTS and _WAK if they are modified.
        '''
        PTS_Serialized = 'NotSerialized'
        WAK_Serialized = 'NotSerialized'
        TTS_Serialized = 'NotSerialized'
        #method = copy.deepcopy(self.__method__)
        for scope in self.__method__.copy():
            for method in self.__method__[scope].copy():
                if not self.__method__[scope][method]['modified']:
                    # skip unmodified method
                    continue
                if '_PTS' in method:
                    self.__method__[scope]['\\_PTS'] = {'content': self.__method__[scope][method]['content'].replace(
                        '_PTS', 'YPTS'), 'modified': True}

                if '_WAK' in method:
                    self.__method__[scope]['\\_WAK'] = {'content': self.__method__[scope][method]['content'].replace(
                        '_WAK', 'YWAK'), 'modified': True}

                if '_TTS' in method:
                    self.__method__[scope]['\\_WAK'] = {'content': self.__method__[scope][method]['content'].replace(
                        '_WAK', 'YWAK'), 'modified': True}

                if '_PTS' in method or '_WAK' in method or '_TTS' in method:
                    try:
                        PTS_Serialized = re.search(
                            '_PTS, 1, (NotSerialized|Serialized)', self.__dsdt_content__).groups()[0]
                    except AttributeError:
                        pass
                    try:
                        WAK_Serialized = re.search(
                            '_WAK, 1, (NotSerialized|Serialized)', self.__dsdt_content__).groups()[0]
                    except AttributeError:
                        pass
                    try:
                        TTS_Serialized = re.search(
                            '_TTS, 1, (NotSerialized|Serialized)', self.__dsdt_content__).groups()[0]
                    except AttributeError:
                        pass

                    self.__method__['\\_SB'] = {'\\_SB.PCI9': {
                        'content': PCI9, 'modified': True}}

                    _PTS = PTS[0] + PTS_Serialized + PTS[1]
                    if '\\_PTS' in self.__method__['\\']:
                        self.__method__['\\']['\\_PTS']['content'] += _PTS
                        self.__method__['\\']['\\_PTS']['modified'] = True
                    else:
                        self.__method__['\\']['\\_PTS'] = {
                            'content': _PTS, 'modified': True}

                    _WAK = WAK[0] + WAK_Serialized + WAK[1]
                    if '\\_WAK' in self.__method__['\\']:
                        self.__method__['\\']['\\_WAK']['content'] += _WAK
                        self.__method__['\\']['\\_WAK']['modified'] = True
                    else:
                        self.__method__['\\']['\\_WAK'] = {
                            'content': _WAK, 'modified': True}

                    _TTS = TTS[0] + TTS_Serialized + TTS[1]
                    if '\\_TTS' in self.__method__['\\']:
                        self.__method__['\\']['\\_TTS']['content'] += _TTS
                        self.__method__['\\']['\\_TTS']['modified'] = True
                    else:
                        self.__method__['\\']['\\_TTS'] = {
                            'content': _TTS, 'modified': True}


    def __insert_osi__(self):
        '''
        Insert 'If (_OSI ('Darwin'))' into each method to avoid affacting Windows which is booted with OpenCore.
        '''
        for scope in self.__method__:
            for method in self.__method__[scope]:
                if not self.__method__[scope][method]['modified']:
                    # skip unmodified method
                    continue
                if "Darwin" in self.__method__[scope][method]['content']:
                    continue
                stack = []
                method_info = re.search(
                    'Method \((\\\?[\w\.]+), (\d+), (NotSerialized|Serialized)\)',
                    self.__method__[scope][method]['content']).groups()

                # Insert if _OSI at the beginning
                self.__method__[scope][method]['content'] = self.__method__[scope][method]['content'].replace(
                    'Method (%s, %s, %s)' % (
                        method_info[0], method_info[1], method_info[2]),
                    'Method (%s, %s, %s) \n{ \nIf (_OSI (\"Darwin\"))' % (
                        method_info[0], method_info[1], method_info[2]),
                )
                for index in range(0, len(self.__method__[scope][method]['content'])):
                    if '{' in self.__method__[scope][method]['content'][index]:
                        stack.append('{')
                    if '}' in self.__method__[scope][method]['content'][index]:
                        stack.pop()
                        if len(stack) == 1:
                            arg = ''
                            for i in range(0, int(method_info[1])):
                                if i > 0:
                                    arg += ', '
                                arg += 'Arg%d' % i
                            # Insert return original method at the bottom
                            self.__method__[scope][method]['content'] = self.__method__[scope][method]['content'][:index] + \
                                '}\n        Else\n        {\n            Return(X%s(%s))\n        }\n' % (
                                method_info[0][-3:], arg) + self.__method__[scope][method]['content'][index:]
                            break

    def __special_devices__(self):
        '''
        This method automatically patch some special laptops. For example, some HP laptop have ACEL device,
        which will cause battery info not able to be updated.
        '''

        def __patch_ACEL__(self):
            '''
            Disable HP laptops' ACEL device
            '''
            print('Patching ACEL...')
            content = self.gc.search(
                '\^\^LPCB\.EC0\.SMWR\s\(0xC6,\s0x50,\s0x22,\s0x40\)\s*\^\^LPCB\.EC0\.SMWR\s\(0xC6,\s0x50,\s0x36,\sOne\)',
                'Method', regex=True)
            for item in content:
                path = item['scope']
                if path not in self.__method__:
                    self.__method__[path] = {}
                self.__method__[path]['%s.ADJT' % path] = {
                    'content': ADJT,
                    'modified': True
                }

        if 'Device (ACEL)' in self.__dsdt_content__ and 'Method (ADJT' in self.__dsdt_content__:
            if 'HPQOEM' not in self.__dsdt_content__:
                print(IS_THIS_HP_LAPTOP)
                inp = input()
                if inp == 'yes' or inp == 'y':
                    __patch_ACEL__(self)
            else:
                __patch_ACEL__(self)

    def __generate_comment__(self):
        # Find mutex and set them to zero
        self.__patch_list__ = []
        mutex = re.findall('Mutex \((.*?), (.*?)\)', self.__dsdt_content__)
        for item in mutex:
            patch = {}
            name = item[0]
            value = int(item[1], 16)
            find = replace = '01'
            if value != 0:
                for c in name:
                    asc = ord(c)
                    find += '%02X' % asc
                    replace += '%02X' % asc
                find += '%02X' % value
                replace += '00'
                patch['comment'] = '[BATT] Set mutex %s to zero' % name
                patch['find'] = find
                patch['replace'] = replace
                self.__patch_list__.append(patch)

        # generate ACPI patch
        for scope in self.__method__:
            for method in self.__method__[scope]:
                if not self.__method__[scope][method]['modified']:
                    # Skip unmodified method
                    continue
                patch = {}
                method_name = re.split(r'[\.\\]', method)[-1]
                try:
                    method_info = list(re.search('Method \((%s), (\d+?), (Serialized|NotSerialized)\)' % method_name,
                                                 self.__method__[scope][method]['content']).groups())
                except AttributeError:
                    continue
                method_info[0] = method_info[0].replace('\\', '')
                if method_info[0] in dangerous_patch_list:
                    # Warning user if this tool patched some dangerous methods
                    print(DANGEROUS_PATCH_MSG[0], method_info[0], DANGEROUS_PATCH_MSG[1],
                          'X%s' % method_info[0][1:], DANGEROUS_PATCH_MSG[2])
                method_info[1] = int(method_info[1])
                if method_info[2] == 'Serialized':
                    method_info[1] += 8
                find = replace = ''
                for c in method_info[0]:
                    asc = ord(c)
                    find += '%02X' % asc
                    replace += '%02X' % asc
                replace = '58' + replace[2:]  # Set the 1st character to 'X'
                find += '%02X' % method_info[1]
                replace += '%02X' % method_info[1]
                patch['comment'] = '[BATT] Rename %s to X%s' % (
                    method_info[0], method_info[0][1:])
                patch['find'] = find
                patch['replace'] = replace
                self.__patch_list__.append(patch)

        # Add comment before dsl file
        self.__comment__ += '/*\n'
        self.__comment__ += '* This battery hot patch is generate by SSDT-BATT_Auto_Gen, \n'
        self.__comment__ += '* which is a python program written by Eric Kwok.\n'
        self.__comment__ += '*\n'
        self.__comment__ += '* Note: Should be compile with -f option.\n'
        self.__comment__ += '* For any support, plese visit https://github.com/the-eric-kwok/SSDT-BATT_Auto_Gen/issues\n'
        self.__comment__ += '*\n'
        self.__comment__ += '* Patched unit: \n'
        for OR in self.__OR_info__:
            self.__comment__ += '* '
            for unit in OR['field_unit']:
                self.__comment__ += '%s ' % unit['name']
            self.__comment__ += '\n'
        self.__comment__ += '*\n'
        for patch in self.__patch_list__:
            self.__comment__ += '* %s\n' % patch['comment']
            self.__comment__ += '* Find:    %s\n' % patch['find']
            self.__comment__ += '* Replace: %s\n' % patch['replace']
            self.__comment__ += '*\n'
        self.__comment__ += '*/\n'

    def __assemble__(self, DUAL_BATT):
        '''
        Grab comments, head, body, tail, and assemble them together.
        '''
        self.__file_generated__ = self.__comment__
        self.__file_generated__ += (self.__head__ + self.__RW_method__)
        for scope in self.__method__:
            for method in self.__method__[scope]:
                if not self.__method__[scope][method]:
                    break
            else:
                self.__file_generated__ += '    Scope (%s)\n    {\n' % scope
                for method in self.__method__[scope]:
                    if not self.__method__[scope][method]['modified']:
                        # Skip unmodified method
                        continue
                    self.__file_generated__ += self.__method__[scope][method]['content'] + '\n'
                self.__file_generated__ += '    }\n'
            # Skip empty scope
            continue
        if DUAL_BATT:
            self.__file_generated__ += SSDT_BATC[0] + self.__PNP0C0A__[0]['scope'] + SSDT_BATC[1]
        self.__file_generated__ += '}\n'

    def __re_indent__(self):
        stack = []
        splited = self.__file_generated__.split('\n')
        # Parse line by line
        for index in range(0, len(splited)):
            # Delete space at front of each line
            splited[index] = splited[index].strip()
            count = splited[index].count('{')
            count -= splited[index].count('}')
            if count < 0:
                for i in range(0, -count):
                    stack.pop()
            # Indent by brackets
            splited[index] = '    ' * len(stack) + splited[index]
            if count > 0:
                for i in range(0, count):
                    stack.append('{')

        self.__file_generated__ = '\n'.join(splited)

    def __write_file__(self):
        '''
        Write to dsl file, and also try to compile it automatically.
        '''
        out_path = []
        out_path.append(os.path.expanduser('~') + os.sep +
                        'Desktop' + os.sep + 'Battery_hotpatch')
        # Replace DSDT with SSDT-BATT and fill it in filename
        out_path.append(os.path.split(
            self.__filepath__.replace('DSDT', 'SSDT-BATT'))[1])
        # Replace dsdt with SSDT-BATT in filename
        out_path[1] = out_path[1].replace('dsdt', 'SSDT-BATT')

        if not os.path.exists(out_path[0]):
            # If directory not exists
            os.makedirs(out_path[0])

        out_file = os.sep.join(out_path)
        out_path = out_path[0]
        try:
            with open(out_file, 'x') as f:
                f.write(self.__file_generated__)
                print(GENERATE_SUCCESSFUL_MSG)
        except FileExistsError:
            for i in range(1, 100):
                test = '.'.join(out_file.split('.')[:-1]) + '_%d.dsl' % i
                try:
                    with open(test, 'x') as f:
                        f.write(self.__file_generated__)
                        out_file = test
                        print(GENERATE_SUCCESSFUL_MSG)
                    break
                except FileExistsError:
                    pass

        if os.path.exists('./iasl') and os.sys.platform == 'darwin':
            with os.popen('./iasl -va -f %s 2>&1' % out_file) as p:
                ret = p.read()
                if 'AML Output' in ret:
                    ret_spl = ret.splitlines()
                    for line in ret_spl:
                        if line.startswith('AML Output'):
                            if ' 0 bytes' not in line:
                                print(COMPILE_SUCCESS_MSG)
                                break
                            else:
                                print(COMPILE_FAILED_ERR)
                                print(ret)
                else:
                    print(COMPILE_FAILED_ERR)
        elif os.path.exists('.\\iasl.exe') and os.sys.platform == 'win32':
            with os.popen('.\\iasl.exe -va -f %s' % out_file) as p:
                ret = p.read()
                if 'AML Output' in ret:
                    ret_spl = ret.splitlines()
                    for line in ret_spl:
                        if line.startswith('AML Output'):
                            if '0 bytes' not in line:
                                print(COMPILE_SUCCESS_MSG)
                                break
                            else:
                                print(COMPILE_FAILED_ERR)
                                print(ret)
                else:
                    print(COMPILE_FAILED_ERR)
        else:
            print(TRY_TO_COMPILE_ANYWAY)
            os.system('iasl -va -f %s' % out_file)

        if os.sys.platform == 'darwin':
            os.system('open ' + out_path)
        elif os.sys.platform == 'win32':
            os.system('start ' + out_path)


def opener(filepath: str):
    try:
        with open(filepath, 'r') as f:
            content = f.read()
            return content
    except UnicodeDecodeError:
        with open(filepath, 'rb') as fb:
            rawdata = fb.read()
            for encoding in ('ascii', 'utf8', 'gbk', 'latin1'):
                try:
                    content = rawdata.decode(encoding)
                    return content
                except UnicodeDecodeError:
                    pass
            try:
                content
            except NameError:
                if __CHARDET__:
                    guessing = chardet.detect(rawdata)
                    if guessing['confidence'] > 0.5:
                        content = rawdata.decode(guessing['encoding'])
                        return content
                raise RuntimeError('File encoding not known')
    except FileNotFoundError:
        print(FILE_NOT_FOUND_ERR)
        exit(1)
    except PermissionError:
        print(PERMISSION_ERR)
        exit(1)


def show_help():
    print(HELP_MESSAGE)
    exit()


def parse_args():
    '''
    Parsing arguments and load file contents

    @return: (filename, filepath, dsdt_content) - tuple(str)
    '''
    global VERBOSE, DEBUG, FORCE
    filename = filepath = dsdt_content = None
    arg_lens = len(sys.argv)
    if arg_lens == 1:
        show_help()
    for arg in sys.argv:
        if '-h' in arg or 'help' in arg:
            show_help()
        if '-v' in arg:
            VERBOSE = True
            get_content_rewrite.set_verbose(True)
        if '-F' in arg or '--force' in arg:
            FORCE = True
        if '-debug' in arg:
            VERBOSE = True
            DEBUG = True
            get_content_rewrite.set_debug(True)
        if '.dsl' in arg:
            filename = arg
            filepath = os.path.abspath(filename)
            dsdt_content = opener(filepath=filepath)
        if '.aml' in arg or '.dat' in arg:
            if os.path.exists('./iasl') and os.sys.platform == 'darwin':
                # print('file: '+arg)
                with os.popen("./iasl -d ' % s' 2>&1" % arg) as p:
                    ret = p.read()
                    if 'ASL Output' in ret:
                        print(DECOMPILE_SUCCESS_MSG)
                    else:
                        print(ret)
                        exit(1)
            elif os.path.exists('.\\iasl.exe') and os.sys.platform == 'win32':
                # print('file: '+arg)
                with os.popen(".\\iasl.exe -d ' % s' 2>&1" % arg) as p:
                    ret = p.read()
                    if 'ASL Output' in ret:
                        print(DECOMPILE_SUCCESS_MSG)
                    else:
                        print(ret)
                        exit(1)
            else:
                print(NO_IASL_COMPILER)
                exit(1)
            filename = arg.replace('.aml', '.dsl')
            filepath = os.path.abspath(filename)
            dsdt_content = opener(filepath=filepath)
    if filepath and dsdt_content:
        return (filepath, dsdt_content)
    else:
        show_help()


if __name__ == '__main__':
    start_time = time.time()
    filepath, __dsdt_content__ = parse_args()

    result = re.findall('PNP0C0A', __dsdt_content__)
    if len(result) < 1:
        print(TOO_FEW_BATT_ERR)
        exit(1)

    # Single battery device
    app = AutoGen(__dsdt_content__, filepath)
    # if VERBOSE:
    print('程序执行用时', time.time() - start_time, '秒')
