#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import os
import re
from multilanguage import *
import time
import get_content

dangerous_patch_list = ['_PTS', '_WAK', '_STA', '_CRS', '_REG', '_ADR', '_PRW', '_DCS', '_DGS', '_DSS', '_INI', '_PS0', '_PS1',
    '_PS2', '_PS3', '_PS4', '_PS5', '_S0D', '_S1D', '_S2D', '_S3D', '_S4D', '_S5D']
VERBOSE = False
DEBUG = False
FORCE = False

class AutoGen:
    OR_info = []
    verbose = False
    debug = False
    head = """DefinitionBlock ("", "SSDT", 2, "ERIC", "BATT", 0x00000000)
{"""
    RW_method = ""
    comment = ""

    def __init__(self, dsdt_content:str, filepath:str) -> None:
        self.dsdt_content = dsdt_content
        self.filepath = filepath
        self.clean_out()
        self.split_dsdt()
        self.EC_content = get_content.search(self.dsdt_content, '"PNP0C09"')
        self.find_OperationRegion()
        self.find_field()
        self.patch_method()
        self.insert_osi()
        self.special_devices()
        self.generate_comment()
        self.assemble()
        self.write_file()

    def clean_out(self):
        '''
        Removes comments, external, Firmware error generated by iasl, etc.
        '''
        # Remove block comments
        self.dsdt_content = re.sub(
            r'/\*[\w\W\n]*?\*/', "", self.dsdt_content)
        # Remove line comments
        self.dsdt_content = re.sub(r'//.*', '', self.dsdt_content)
        # Remove "External" declaration
        self.dsdt_content = re.sub(r'External \(.*Obj\)\n', "", self.dsdt_content)
        # Remove "Firmware Error" that generated within disassambling
        self.dsdt_content = re.sub(
            r'Firmware Error.*\n', "", self.dsdt_content)
        # Remove empty lines
        self.dsdt_content = re.sub(r'^\n', "", self.dsdt_content)

    def split_dsdt(self):
        '''
        Spliting dsdt content by space. Will not remove spaces if not in debug mode.
        '''
        self.dsdt_splited = self.dsdt_content.split(' ')
        if DEBUG:
            length = len(self.dsdt_splited)
            for i in range(0, length):
                # remove spaces
                i = length - i - 1
                if self.dsdt_splited[i] == '':
                    del self.dsdt_splited[i]
        

    def find_OperationRegion(self):
        '''
        Finding OperationRegion(s) inside EC scope.
        '''
        EC_content = self.EC_content
        for dev in EC_content:
            OR_list = re.findall(
                "OperationRegion \\(([A-Z0-9]{4}),", EC_content[dev])
            for OR in OR_list:
                OR_info = re.search(  # 使用分组来获得 OperationRegion 的信息
                    "OperationRegion \\(%s, ([a-zA-Z].*), ([a-zA-Z0-9].*), ([a-zA-Z0-9].*)\\)" % OR, EC_content[dev])
                try:
                    self.OR_info.append({
                        "Path": dev,
                        "Name": OR,
                        "Storage": OR_info.group(1),
                        "Offset": OR_info.group(2),
                        "Length": OR_info.group(3)
                    })
                except AttributeError:
                    continue
        if VERBOSE:
            for item in self.OR_info:
                print(item)
            print()

    def rename(self, orig_name: str):
        '''
        Method to rename field unit / method / device / anything without conflicting with one already there.

        @param: orig_name(str) - original name

        @return: new_name(str) - renamed name
        '''
        alphabet = ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                    'A', 'B', 'C', 'D', 'E', 'F', 'G',
                    'H', 'I', 'J', 'K', 'L', 'M', 'N',
                    'O', 'P', 'Q', 'R', 'S', 'T',
                    'U', 'V', 'W', 'X', 'Y', 'Z')
        for char in alphabet:
            new_name = orig_name[:3]+char
            if self.dsdt_content.find(new_name) == -1:
                return new_name

    def find_field(self):
        '''
        Finding out which unit field is going to be patched inside EC scope.
        '''
        self.modified_fieldunit = []
        for OR_info in self.OR_info:
            OR_path = OR_info["Path"]+'.'+OR_info["Name"]
            content = get_content.get_content(self.dsdt_content, OR_path)
            splited = content.split("}")
            for field in splited[:-1]:
                flag = False  # Is there any field that needs special R/W in this method?
                tmp = field.split('{')
                field_content = tmp[1].split('\n')
                offset_bit = 0  # Offset in bits
                name = ''
                size = 0
                for item in field_content:
                    if ',' not in item:
                        # Skip empty line
                        continue
                    elif "Offset" not in item:
                        a = item.split(',')
                        name = a[0].strip()
                        size = int(a[1].strip())
                        if size > 8 and name != '':
                            if offset_bit/8 - int(offset_bit/8) != 0:
                                print(FIELD_UNIT_OFFSET_ERR)
                                exit(2)
                            self.modified_fieldunit.append(
                                {"name": name, "offset": int(offset_bit/8), "size": size, "OR path": OR_path})
                            flag = True
                        offset_bit += size
                    else:
                        item = item.strip()
                        offset = re.search(r'Offset \((.*)\)', item).group(1)
                        offset_bit = int(offset, 16) * 8

                if flag:
                    if OR_info["Storage"] not in self.RW_method and OR_info["Path"] not in self.RW_method:
                        self.RE1B = self.rename('R1B')
                        self.RECB = self.rename('RDB')
                        self.ERM2 = self.rename('MEM')
                        self.WE1B = self.rename('W1B')
                        self.WECB = self.rename('WRB')
                    for item in self.modified_fieldunit:
                        if item["OR path"] == OR_path:
                            item["read method"] = self.RECB
                            item["write method"] = self.WECB
                        self.RW_method = '''
    Scope (%s)
    {
        Method (%s, 1, NotSerialized)
        {
            OperationRegion (%s, %s, Arg0, One)
            Field (%s, ByteAcc, NoLock, Preserve)
            {
                BYTE,   8
            }

            Return (BYTE) /* \RE1B.BYTE */
        }

        Method (%s, 2, Serialized)
        {
            // RECB or RSMB
            // Arg0 - offset in bytes from zero-based EC
            // Arg1 - size of buffer in bits
            Arg1 = ((Arg1 + 0x07) >> 0x03)
            Name (TEMP, Buffer (Arg1){})
            Arg1 += Arg0
            Local0 = Zero
            While ((Arg0 < Arg1))
            {
                TEMP [Local0] = %s (Arg0)
                Arg0++
                Local0++
            }

            Return (TEMP) /* \RECB.TEMP */
        }

        Method (%s, 2, NotSerialized)
        {
            OperationRegion (%s, %s, Arg0, One)
            Field (%s, ByteAcc, NoLock, Preserve)
            {
                BYTE,   8
            }

            BYTE = Arg1
        }

        Method (%s, 3, Serialized)
        {
            // WECB or WSMB
            // Arg0 - offset in bytes from zero-based EC
            // Arg1 - size of buffer in bits
            // Arg2 - data to be written
            Arg1 = ((Arg1 + 0x07) >> 0x03)
            Name (TEMP, Buffer (Arg1){})
            TEMP = Arg2
            Arg1 += Arg0
            Local0 = Zero
            While ((Arg0 < Arg1))
            {
                %s (Arg0, DerefOf (TEMP [Local0]))
                Arg0++
                Local0++
            }
        }
    }
''' % (OR_info["Path"], self.RE1B, self.ERM2, OR_info["Storage"], 
            self.ERM2, self.RECB, self.RE1B, self.WE1B, self.ERM2, 
            OR_info["Storage"], self.ERM2, self.WECB, self.WE1B)
        if "RECB" not in self.RW_method:
            print(NOT_NEED_TO_PATCH_MSG)
            exit(0)

    def patch_method(self):
        '''
        Getting method content by unit fields which is going to be patched. And patch each method returned.
        '''
        self.method_to_patch = {}
        # Getting method content
        for unit in self.modified_fieldunit:
            if VERBOSE:
                print("Unit:", unit)
            result = get_content.search(self.dsdt_content, unit["name"])
            for name in result:
                scope = '.'.join(name.split('.')[:-1])
                if scope == "":
                    # Handle method like "Method (\WAK)"
                    scope = "\\"
                try:
                    if name in self.method_to_patch[scope] or ("EC" not in name and "EC" not in result[name]):
                        # remove duplicates, and remove fieldunit that not in EC scope
                        continue
                except KeyError:
                    if "EC" not in name and "EC" not in result[name]:
                        # Remove fieldunit that not in EC scope
                        continue
                if scope not in self.method_to_patch:
                    self.method_to_patch[scope] = {}
                self.method_to_patch[scope][name] = result[name]

        # Patching method
        for scope in self.method_to_patch:
            for method in self.method_to_patch[scope]:
                if VERBOSE:
                    print("\n%s\n| Patching: %s |\n%s" % ('='*(14+len(method)), method, '='*(14+len(method))))
                for unit in self.modified_fieldunit:
                    if VERBOSE:
                        print("Parsing", unit)
                    # Patch field writing, e.g. UNIT = xxxx
                    reserve = re.findall("%s = (\\w+)" % unit['name'], self.method_to_patch[scope][method])
                    for item in reserve:
                        self.method_to_patch[scope][method] = self.method_to_patch[scope][method].replace(
                            "%s = %s" % (unit['name'], item), 
                            "%s (0x%X, %s, %s)" % (unit["write method"], 
                                int(unit["offset"]), unit["size"], item)
                        )

                    # Patch field writing, e.g. Store (xxxx, UNIT)
                    reserve = re.findall("Store \\((\\w+), %s\\)" % unit['name'], 
                        self.method_to_patch[scope][method])
                    for item in reserve:
                        self.method_to_patch[scope][method] = self.method_to_patch[scope][method].replace(
                            "Store (%s, %s)" % (item, unit['name']),
                            "%s (0x%X, %s, %s)" % (unit["write method"], 
                                int(unit["offset"]), unit["size"], item)
                        )

                    # Patch field reading
                    reserve = re.findall("(.*[^/])%s(\\W|\n)" % unit['name'], 
                        self.method_to_patch[scope][method])
                    for i in range(0, len(reserve)):
                        if "Method (" in reserve[i][0] or "Device (" in reserve[i][0]:
                            continue  # stop patching method that have the same name as fieldunit
                        self.method_to_patch[scope][method] = self.method_to_patch[scope][method].replace(
                            reserve[i][0]+unit['name']+reserve[i][1], 
                            '%s%s (0x%X, %s)%s' % (reserve[i][0], unit['read method'], 
                                int(unit['offset']), unit['size'], reserve[i][1]), 
                        )

                modified = False
                for unit in self.modified_fieldunit:
                    if unit['read method'] in self.method_to_patch[scope][method] or unit['write method'] in self.method_to_patch[scope][method]:
                        modified = True
                if not modified:
                    self.method_to_patch[scope][method] = None
                


    def insert_osi(self):
        '''
        Insert 'If (_OSI ("Darwin"))' into each method to avoid affacting Windows which is booted with OpenCore.
        '''
        for scope in self.method_to_patch:
            for method in self.method_to_patch[scope]:
                if not self.method_to_patch[scope][method]:
                    # Skip deleted method
                    continue
                stack = []
                method_info = re.search(
                    'Method \((\\\?[\w\.]+), (\d+), (NotSerialized|Serialized)\)', 
                    self.method_to_patch[scope][method]).groups()

                # Insert if _OSI at the beginning
                self.method_to_patch[scope][method] = re.sub(
                    'Method \((\\\?[\w\.]+), (\d+), (NotSerialized|Serialized)\)', 
                    "Method (%s, %s, %s) \n{ \nIf (_OSI (\"Darwin\"))" % (
                    method_info[0], method_info[1], method_info[2]), 
                    self.method_to_patch[scope][method])

                for index in range(0, len(self.method_to_patch[scope][method])):
                    if "{" in self.method_to_patch[scope][method][index]:
                        stack.append('{')
                    if "}" in self.method_to_patch[scope][method][index]:
                        stack.pop()
                        if len(stack) == 1:
                            arg = ''
                            for i in range(0, int(method_info[1])):
                                if i > 0:
                                    arg += ', '
                                arg += 'Arg%d' % i
                            # Insert return original method at the bottom
                            self.method_to_patch[scope][method] = self.method_to_patch[scope][method][:index] + \
                                "}\n        Else\n        {\n            Return(X%s(%s))\n        }\n" % (
                                method_info[0][-3:], arg) + self.method_to_patch[scope][method][index:]
                            break

                stack = []
                splited = self.method_to_patch[scope][method].split('\n')
                # Parse line by line
                for index in range(0, len(splited)):
                    # Delete space at front of each line
                    splited[index] = splited[index].strip()
                    if '}' in splited[index]:
                        if '{' not in splited[index]:
                            stack.pop()
                    # Indent by brackets
                    splited[index] = "    " * (len(stack) + 2) + splited[index]
                    if '{' in splited[index]:
                        if '}' not in splited[index]:
                            stack.append('{')

                self.method_to_patch[scope][method] = '\n'.join(splited)

    def patch_ACEL(self):
        '''
        Disable HP laptops' ACEL device
        '''
        print("Patching ACEL...")
        content = get_content.search(self.dsdt_content, "(ACEL)")
        for dev in content:
            if dev not in self.method_to_patch:
                self.method_to_patch[dev] = {}
            self.method_to_patch[dev]["%s._STA"%dev] = '''        Method (_STA, 0, NotSerialized) 
        {
            If (_OSI("Darwin")) 
            {
                Return (0)
            }
            Else 
            {
                Return(XSTA())
            }
        }
'''

    def special_devices(self):
        '''
        This method automatically patch some special laptops. For example, some HP laptop have ACEL device, 
        which will cause battery info not able to be updated.
        '''
        if "Device (ACEL)" in self.dsdt_content:
            if "HPQOEM" not in self.dsdt_content:
                print(IS_THIS_HP_LAPTOP)
                inp = input()
                if inp == 'yes' or inp == 'y':
                    self.patch_ACEL()
            self.patch_ACEL()

    def generate_comment(self):
        # Find mutex and set them to zero
        mutex = re.findall("Mutex \((.*?), (.*?)\)", self.dsdt_content)
        for item in mutex:
            name = item[0]
            value = int(item[1], 16)
            find = replace = '01'
            if value != 0:
                for c in name:
                    asc = ord(c)
                    find += "%02X" % asc
                    replace += "%02X" % asc
                find += "%02X" % value
                replace += "00"
                self.comment += '''// Set mutex %s to zero
// Find:    %s
// Replace: %s

''' % (name, find, replace)

        # generate ACPI patch
        for scope in self.method_to_patch:
            for method in self.method_to_patch[scope]:
                if not self.method_to_patch[scope][method]:
                    # Skip deleted method
                    continue
                method_info = list(re.search("Method \((.*?), (\d+?), (Serialized|NotSerialized)\)", 
                    self.method_to_patch[scope][method]).groups())
                method_info[0] = method_info[0].replace("\\", "")
                if method_info[0] in dangerous_patch_list:
                    # Warning user if this tool patched some dangerous methods
                    print(DANGEROUS_PATCH_MSG[0], method_info[0], DANGEROUS_PATCH_MSG[1],
                        'X%s' % method_info[0][1:], DANGEROUS_PATCH_MSG[2])
                method_info[1] = int(method_info[1])
                if method_info[2] == 'Serialized':
                    method_info[1] += 8
                find = replace = ''
                for c in method_info[0]:
                    asc = ord(c)
                    find += "%02X" % asc
                    replace += "%02X" % asc
                replace = "58" + replace[2:]  # Set the 1st character to 'X'
                find += "%02X" % method_info[1]
                replace += "%02X" % method_info[1]
                self.comment += '''// Rename %s to X%s
// Find:    %s
// Replace: %s

''' % (method_info[0], method_info[0][1:], find, replace)

    def assemble(self):
        '''
        Grab comments, head, body, tail, and assemble them together. 
        '''
        self.file_generated = self.comment
        self.file_generated += (self.head + self.RW_method)
        for scope in self.method_to_patch:
            have_method = False
            for method in self.method_to_patch[scope]:
                if self.method_to_patch[scope][method]:
                    have_method = True
            if not have_method:
                # Skip empty scope
                continue
            self.file_generated += "    Scope (%s)\n    {\n" % scope
            for method in self.method_to_patch[scope]:
                if not self.method_to_patch[scope][method]:
                    # Skip deleted method
                    continue
                self.file_generated += self.method_to_patch[scope][method] + '\n'
            self.file_generated += "    }\n"
        self.file_generated += '}\n'

    def write_file(self):
        '''
        Write to dsl file, and also try to compile it automatically.
        '''
        out_path = []
        out_path.append(os.getcwd() + os.sep + 'Product')
        out_path.append(os.path.split(self.filepath.replace("DSDT", "SSDT-BATT"))[1])
        out_path[1] = out_path[1].replace("dsdt", "SSDT-BATT")

        if not os.path.exists(out_path[0]):
            # If directory not exists
            os.makedirs(out_path[0])

        out_path = os.sep.join(out_path)
        try:
            with open(out_path, 'x') as f:
                f.write(self.file_generated)
                print(GENERATE_SUCCESSFUL_MSG)
        except FileExistsError:
            for i in range(1, 100):
                test = '.'.join(out_path.split('.')[:-1]) + '_%d.dsl' % i
                try:
                    with open(test, 'x') as f:
                        f.write(self.file_generated)
                        print(GENERATE_SUCCESSFUL_MSG)
                    break
                except FileExistsError:
                    pass
        
        if os.path.exists('./iasl') and os.sys.platform == "darwin":
            with os.popen("./iasl -f %s 2>&1" % out_path) as p:
                ret = p.read()
                if "AML Output" in ret:
                    print(COMPILE_SUCCESS_MSG)
                else:
                    print(ret)
        elif os.path.exists('.\\iasl.exe') and os.sys.platform == 'win32':
            with os.popen(".\\iasl.exe -f %s" % out_path) as p:
                ret = p.read()
                if "AML Output" in ret:
                    print(COMPILE_SUCCESS_MSG)
                else:
                    print(ret)
        else:
            print(TRY_TO_COMPILE_ANYWAY)
            os.system('iasl -f %s' % out_path)

def opener(filepath:str):
    try:
        with open(filepath, 'r') as f:
            content = f.read()
    except FileNotFoundError:
        print(FILE_NOT_FOUND_ERR)
        exit(1)
    except PermissionError:
        print(PERMISSION_ERR)
        exit(1)
    return content

def show_help():
    print(HELP_MESSAGE)
    exit()

def parse_args():
    '''
    Parsing arguments and load file contents

    @return: (filename, filepath, dsdt_content) - tuple(str)
    '''
    global VERBOSE, DEBUG, FORCE
    filename = filepath = dsdt_content = None
    arg_lens = len(sys.argv)
    if arg_lens == 1:
        show_help()
    for arg in sys.argv:
        if '-h' in arg or 'help' in arg:
            show_help()
        if '-v' in arg:
            VERBOSE = True
        if '-F' in arg or '--force' in arg:
            FORCE = True
        if '-debug' in arg:
            VERBOSE = True
            DEBUG = True
        if '.dsl' in arg:
            filename = arg
            filepath = os.path.abspath(filename)
            dsdt_content = opener(filepath=filepath)
        if '.aml' in arg:
            if os.path.exists('./iasl') and os.sys.platform == "darwin":
                with os.popen("./iasl %s 2>&1" % arg) as p:
                    ret = p.read()
                    if "ASL Output" in ret:
                        print(DECOMPILE_SUCCESS_MSG)
                    else:
                        print(ret)
                        exit(1)
            elif os.path.exists('.\\iasl.exe') and os.sys.platform == 'win32':
                with os.popen(".\\iasl.exe %s" % arg) as p:
                    ret = p.read()
                    if "ASL Output" in ret:
                        print(DECOMPILE_SUCCESS_MSG)
                    else:
                        print(ret)
                        exit(1)
            else:
                print(NO_IASL_COMPILER)
                exit(1)
            filename = arg.replace('.aml', '.dsl')
            filepath = os.path.abspath(filename)
            dsdt_content = opener(filepath=filepath)
    if filepath and dsdt_content:
        return (filepath, dsdt_content)
    else:
        show_help()

if __name__ == '__main__':
    start_time = time.time()
    filepath, dsdt_content = parse_args()

    result = re.findall("PNP0C0A", dsdt_content)
    if not FORCE:
        if len(result) > 1:
            print(TOO_MANY_BATT_ERR)
            exit(1)
        elif len(result) < 1:
            print(TOO_FEW_BATT_ERR)
            exit(1)
    
    # Single battery device
    app = AutoGen(filepath=filepath, dsdt_content=dsdt_content)
    if VERBOSE:
        print("程序执行用时", time.time() - start_time, "秒")
