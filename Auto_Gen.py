#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from os import replace
import random
import sys
import os
import re
from multilanguage import *
import time
import get_content
from cons_strings import *
import copy

# Third party libraies
try:
    import chardet
    __CHARDET__ = True
except ImportError:
    __CHARDET__ = False

dangerous_patch_list = ['_STA', '_CRS', '_REG', '_ADR', '_PRW', '_DCS', '_DGS', '_DSS', '_INI', '_PS0', '_PS1',
                        '_PS2', '_PS3', '_PS4', '_PS5', '_S0D', '_S1D', '_S2D', '_S3D', '_S4D', '_S5D']
VERBOSE = False
DEBUG = False
FORCE = False


class AutoGen:
    OR_info = []
    verbose = False
    debug = False
    head = HEAD
    RW_method = ""
    comment = ""

    def __init__(self, dsdt_content: str, filepath: str) -> None:
        self.dsdt_content = dsdt_content
        self.filepath = filepath
        self.clean_out()
        self.split_dsdt()
        self.EC_content = get_content.search(self.dsdt_content, '"PNP0C09"')
        self.find_OperationRegion()
        self.find_field()
        self.patch_method()
        self.patch_PTSWAK()
        self.insert_osi()
        self.special_devices()
        self.generate_comment()
        self.assemble()
        self.re_indent()
        self.write_file()

    def clean_out(self):
        '''
        Removes comments, external, Firmware error generated by iasl, etc.
        '''
        # Remove block comments
        self.dsdt_content = re.sub(
            r'/\*[\w\W\n]*?\*/', "", self.dsdt_content)
        # Remove line comments
        self.dsdt_content = re.sub(r'//.*', '', self.dsdt_content)
        # Remove "External" declaration
        self.dsdt_content = re.sub(
            r'External \(.*Obj\)\n', "", self.dsdt_content)
        # Remove "Firmware Error" that generated within disassambling
        self.dsdt_content = re.sub(
            r'Firmware Error.*\n', "", self.dsdt_content)
        # Remove empty lines
        self.dsdt_content = re.sub(r'^\n', "", self.dsdt_content)

    def split_dsdt(self):
        '''
        Spliting dsdt content by space. Will not strip them if not in debug mode.
        '''
        if DEBUG:
            dsdt_splitline = self.dsdt_content.splitlines()
            for i in range(0, len(dsdt_splitline)):
                dsdt_splitline[i].strip()
            self.dsdt_content = '\n'.join(dsdt_splitline)
        self.dsdt_splited = self.dsdt_content.split(' ')

    def find_OperationRegion(self):
        '''
        Finding OperationRegion(s) inside EC scope.
        '''
        if VERBOSE:
            print(
                "Into: find_OperationRegion(): Finding OperationRegion(s) inside EC scope.")
        EC_content = self.EC_content
        for dev in EC_content:
            OR_list = re.findall(
                "OperationRegion \\(([A-Z0-9]{2,4}),", EC_content[dev])
            for OR in OR_list:
                OR_info = re.search(  # Getting info of OperationRegions by re.group
                    "OperationRegion \\(%s, ([a-zA-Z].*), ([a-zA-Z0-9].*), ([a-zA-Z0-9].*)\\)" % OR, EC_content[dev])
                try:
                    if OR_info.group(2) == 'Zero':
                        offset = 0
                    elif OR_info.group(2) == 'One':
                        offset = 1
                    elif 'Arg' in OR_info.group(2):
                        continue  # TODO
                    elif '0x' in OR_info.group(2):
                        offset = int(OR_info.group(2), 16)
                    else:
                        offset = OR_info.group(2)
                    self.OR_info.append({
                        "path": dev,
                        "name": OR,
                        "storage": OR_info.group(1),
                        "offset": offset,
                        "length": OR_info.group(3)
                    })
                except AttributeError:
                    continue
        if VERBOSE:
            for item in self.OR_info:
                print(item)
            print()

    def find_field(self):
        '''
        Finding out which unit field is going to be patched inside EC scope.
        '''
        if VERBOSE:
            print(
                "Into: find_field(): Finding out which unit field is going to be patched inside EC scope.")
        for OR in self.OR_info:
            OR["field_unit"] = []
            OR_path = OR["path"]+'.'+OR["name"]
            content = get_content.get_content(self.dsdt_content, OR_path)
            for field in content.split("}")[:-1]:
                field = field.split('{')[1]  # Remove field header
                store_flag = False  # Is there any field that larger than 16 bits in this method?
                field_content_splln = field.split('\n')
                offset_bits = 0  # offset in bits
                name = ''
                size = 0
                for item in field_content_splln:
                    if ',' not in item:
                        # Skip empty line
                        continue
                    elif "Offset" not in item:
                        item_spl = item.split(',')
                        name = item_spl[0].strip()
                        size = int(item_spl[1].strip())
                        if size > 8 and name != '':
                            if offset_bits/8 - int(offset_bits/8) != 0:
                                print(FIELD_UNIT_OFFSET_ERR)
                                exit(2)
                            OR["field_unit"].append(
                                {"name": name, "offset": int(offset_bits/8), "size": size, "OR_path": OR_path})
                            store_flag = True
                        offset_bits += size
                    else:
                        item = item.strip()
                        offset = re.search(r'Offset \((.*)\)', item).group(1)
                        offset_bits = int(offset, 16) * 8

                if store_flag:
                    # Store this OperationRegion and its units
                    if OR["storage"] not in self.RW_method:
                        while True:
                            # This will generate a new R/W method name
                            letter = random.choice(
                                '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ')
                            OR['RE1B'] = 'R1B'+letter
                            OR['RECB'] = 'REB' + letter
                            OR['ERM2'] = 'MEM'+letter
                            OR['WE1B'] = 'W1B'+letter
                            OR['WECB'] = 'WRB' + letter
                            if (self.dsdt_content.find(OR['RE1B']) == -1 and OR['RE1B'] not in self.RW_method) \
                                    and (self.dsdt_content.find(OR['RECB']) == -1 and OR['RECB'] not in self.RW_method) \
                                    and (self.dsdt_content.find(OR['ERM2']) == -1 and OR['ERM2'] not in self.RW_method) \
                                    and (self.dsdt_content.find(OR['WE1B']) == -1 and OR['WE1B'] not in self.RW_method) \
                                    and (self.dsdt_content.find(OR['WECB']) == -1 and OR['WECB'] not in self.RW_method):
                                # Loop until there is nothing has the same name as our generated one
                                break

                        # Add the content of R/W method to self.RW_method
                        self.RW_method += RW_METHOD[0] + \
                            OR["path"] + RW_METHOD[1] +\
                            OR['RE1B'] + RW_METHOD[2] + \
                            OR['ERM2'] + RW_METHOD[3] + \
                            OR["storage"] + RW_METHOD[4] + \
                            OR['ERM2'] + RW_METHOD[5] + \
                            OR['RECB'] + RW_METHOD[6] + \
                            OR['RE1B'] + RW_METHOD[7] + \
                            OR['WE1B'] + RW_METHOD[8] + \
                            OR['ERM2'] + RW_METHOD[9] + \
                            OR["storage"] + RW_METHOD[10] + \
                            OR['ERM2'] + RW_METHOD[11] + \
                            OR['WECB'] + RW_METHOD[12] + \
                            OR['WE1B'] + RW_METHOD[13]
                    else:
                        # If OR['storage'] in self.RW_method and not in OR itself
                        # Then copy the read/write method from other OR which has the same storage
                        for _OR_ in self.OR_info:
                            if _OR_['storage'] == OR['storage']:
                                OR['RE1B'] = _OR_['RE1B']
                                OR['RECB'] = _OR_['RECB']
                                OR['ERM2'] = _OR_['ERM2']
                                OR['WE1B'] = _OR_['WE1B']
                                OR['WECB'] = _OR_['WECB']
                                break

        for OR in self.OR_info:
            if len(OR['field_unit']) < 1:
                self.OR_info.remove(OR)

        if "RECB" not in self.RW_method:
            print(NOT_NEED_TO_PATCH_MSG)
            exit(0)

        if VERBOSE:
            for OR in self.OR_info:
                print(OR['path'] + '.' + OR['name'] + ', ' + OR['storage'])
                for unit in OR['field_unit']:
                    print('  -', unit)

    def patch_method(self):
        '''
        Getting method content by unit fields which is going to be patched. And patch each method returned.
        '''
        self.method = {}
        for OR in self.OR_info:
            # Getting method content
            for unit in OR["field_unit"]:
                result = get_content.search(self.dsdt_content, unit["name"])
                for name in result:
                    if result[name].split()[0] != "Method":
                        # Ignore content which is not Method
                        continue
                    scope = '.'.join(name.split('.')[:-1])
                    if scope == "":
                        # Handle method like "Method (\WAK)"
                        scope = "\\"
                    try:
                        if name in self.method[scope] or ("EC" not in name and "EC" not in result[name]):
                            # remove duplicates, and remove fieldunit that not in EC scope
                            continue
                    except KeyError:
                        if "EC" not in name and "EC" not in result[name]:
                            # Remove fieldunit that not in EC scope
                            continue
                    if scope not in self.method:
                        self.method[scope] = {}
                    self.method[scope][name] = {
                        "content": result[name], "modified": False}

            # Patching method
            for scope in self.method:
                for method in self.method[scope]:
                    lines = self.method[scope][method]["content"].splitlines()
                    if VERBOSE:
                        print("\n%s\n| Patching: %s |\n%s" % (
                            '='*(14+len(method)), method, '='*(14+len(method))))
                    for unit in OR["field_unit"]:
                        if VERBOSE:
                            print("Parsing", unit)
                        unit_path = '.'.join(unit['OR_path'].split('.')[:-1])
                        if unit_path in scope:
                            # Patch field writing, e.g. UNIT = xxxx
                            reserve = re.findall(
                                "([^\.])%s = (\\w+)" % unit['name'], self.method[scope][method]["content"])
                            for item in reserve:
                                for line in lines:
                                    target = "%s%s = %s" % (
                                        item[0], unit['name'], item[1])
                                    if target in line:
                                        replace = "%s%s (0x%X, %s, %s)" % (item[0], OR['WECB'],
                                                                           unit["offset"] + OR["offset"], unit["size"], item[1])
                                        replace = line.replace(
                                            target, replace) + ' // %s.%s' % (unit_path, unit['name'])
                                        self.method[scope][method]["content"] = self.method[scope][method]["content"].replace(
                                            line, replace)
                                self.method[scope][method]['modified'] = True

                            # Patch field writing, e.g. Store (xxxx, UNIT)
                            reserve = re.findall("Store \\((\\w+), %s\\)" % unit['name'],
                                                 self.method[scope][method]["content"])
                            for item in reserve:
                                for line in lines:
                                    target = "Store (%s, %s)" % (
                                        item, unit['name'])
                                    if target in line:
                                        replace = "%s (0x%X, %s, %s)" % (OR['WECB'],
                                                                         unit["offset"] + OR["offset"], unit["size"], item)
                                        replace = line.replace(
                                            target, replace) + ' // %s.%s' % (unit_path, unit['name'])
                                        self.method[scope][method]["content"] = self.method[scope][method]["content"].replace(
                                            line, replace)
                                self.method[scope][method]['modified'] = True

                            # Patch field reading, e.g. xxxx = ECRD (RefOf (UNIT)) to xxxx = B1B2 (ECRD (RefOf (UNI0)), ECRD (RefOf (UNI1)))
                            reserve = re.findall("(.*)ECRD \(RefOf \(%s\)\)(.*)" % unit['name'],
                                                 self.method[scope][method]['content'])
                            for item in reserve:
                                for line in lines:
                                    target = '%sECRD (RefOf (%s))%s' % (
                                        item[0], unit['name'], item[1])
                                    if target in line:
                                        replace = '%s%s (0x%X, %s)%s' % (
                                            item[0], OR['RECB'], unit['offset'] + OR['offset'], unit['size'], item[1])
                                        replace = line.replace(
                                            target, replace) + ' // %s.%s' % (unit_path, unit['name'])
                                        self.method[scope][method]["content"] = self.method[scope][method]["content"].replace(
                                            line, replace)
                                self.method[scope][method]['modified'] = True

                            # Patch field reading, e.g. xxxx = UNIT
                            reserve = re.findall("(.*[^\.a-zA-Z])%s([^a-zA-Z0-9\.].*)" % unit['name'],
                                                 self.method[scope][method]['content'])
                            for item in reserve:
                                if "Method (" in item[0] or "Device (" in item[0] or "Scope (" in item[0]:
                                    continue  # stop patching method that have the same name as fieldunit
                                for line in lines:
                                    target = item[0] + unit['name'] + item[1]
                                    if target in line:
                                        replace = '%s%s (0x%X, %s)%s' % (item[0], OR['RECB'],
                                                                         unit['offset'] + OR["offset"], unit['size'], item[1])
                                        replace = line.replace(
                                            target, replace) + ' // %s.%s' % (unit_path, unit['name'])
                                        self.method[scope][method]["content"] = self.method[scope][method]["content"].replace(
                                            line, replace)
                                self.method[scope][method]['modified'] = True

                        else:
                            # Patch field writing, e.g. EC0.UNIT = xxxx
                            reserve = re.findall("(.*%s\.)%s = (\\w+)" % (unit['OR_path'].split('.')[-2], unit['name']),
                                                 self.method[scope][method]["content"])
                            for item in reserve:
                                for line in lines:
                                    target = "%s%s = %s" % (
                                        item[0], unit['name'], item[1])
                                    if target in line:
                                        replace = "%s%s (0x%X, %s, %s)" % (item[0], OR['WECB'],
                                                                           unit["offset"] + OR["offset"], unit["size"], item[1])
                                        replace = line.replace(
                                            target, replace) + ' // %s.%s' % (unit_path, unit['name'])
                                        self.method[scope][method]["content"] = self.method[scope][method]["content"].replace(
                                            line, replace)
                                self.method[scope][method]['modified'] = True

                            # Patch field writing, e.g. Store (xxxx, UNIT)
                            reserve = re.findall("Store \\((\\w+), (.*%s.)%s\\)" % (unit['OR_path'].split('.')[-2], unit['name']),
                                                 self.method[scope][method]["content"])
                            for item in reserve:
                                for line in lines:
                                    target = "Store (%s, %s%s)" % (
                                        item[0], item[1], unit['name'])
                                    if target in line:
                                        replace = "%s%s (0x%X, %s, %s)" % (item[1], OR['WECB'],
                                                                           unit["offset"] + OR["offset"], unit["size"], item[0])
                                        replace = line.replace(
                                            target, replace) + ' // %s.%s' % (unit_path, unit['name'])
                                        self.method[scope][method]["content"] = self.method[scope][method]["content"].replace(
                                            line, replace)
                                self.method[scope][method]['modified'] = True

                            # Patch field reading, e.g. xxxx = ECRD (RefOf (UNIT)) to xxxx = B1B2 (ECRD (RefOf (UNI0)), ECRD (RefOf (UNI1)))
                            reserve = re.findall("(.*)ECRD \(RefOf \((.*%s\.)%s\)\)(.*)" % (unit['OR_path'].split('.')[-2], unit['name']),
                                                 self.method[scope][method]['content'])
                            for item in reserve:
                                for line in lines:
                                    target = '%sECRD (RefOf (%s%s))%s' % (
                                        item[0], item[1], unit['name'], item[2])
                                    if target in line:
                                        replace = '%s%s%s (0x%X, %s)%s' % (
                                            item[0], item[1], OR['RECB'], unit['offset'] + OR['offset'], unit['size'], item[2])
                                        replace = line.replace(
                                            target, replace) + ' // %s.%s' % (unit_path, unit['name'])
                                        self.method[scope][method]["content"] = self.method[scope][method]["content"].replace(
                                            line, replace)
                                self.method[scope][method]['modified'] = True

                            # Patch field reading, e.g. xxxx = EC0.UNIT
                            reserve = re.findall("(.*%s\.)%s([^a-zA-Z0-9\.].*)" % (unit['OR_path'].split('.')[-2], unit['name']),
                                                 self.method[scope][method]['content'])
                            for item in reserve:
                                for line in lines:
                                    if "Method (" in item[0] or "Device (" in item[0] or "Scope (" in item[0]:
                                        continue  # stop patching method that have the same name as fieldunit
                                    target = item[0] + unit['name'] + item[1]
                                    if target in line:
                                        replace = '%s%s (0x%X, %s)%s' % (item[0], OR['RECB'],
                                                                         unit['offset'] + OR["offset"], unit['size'], item[1])
                                        replace = line.replace(
                                            target, replace) + ' // %s.%s' % (unit_path, unit['name'])
                                        self.method[scope][method]["content"] = self.method[scope][method]["content"].replace(
                                            line, replace)
                                self.method[scope][method]['modified'] = True

    def patch_PTSWAK(self):
        '''
        Patch _PTS and _WAK if they are modified.
        '''
        PTS_Serialized = 'NotSerialized'
        WAK_Serialized = 'NotSerialized'
        TTS_Serialized = 'NotSerialized'
        method_new = copy.deepcopy(self.method)
        for scope in self.method:
            for method in self.method[scope]:
                if not self.method[scope][method]['modified']:
                    # skip unmodified method
                    continue
                if '_PTS' in method:
                    method_new[scope]['\\_PTS'] = {'content': self.method[scope][method]['content'].replace(
                        '_PTS', 'YPTS'), 'modified': True}

                if '_WAK' in method:
                    method_new[scope]['\\_WAK'] = {'content': self.method[scope][method]['content'].replace(
                        '_WAK', 'YWAK'), 'modified': True}

                if '_TTS' in method:
                    method_new[scope]['\\_WAK'] = {'content': self.method[scope][method]['content'].replace(
                        '_WAK', 'YWAK'), 'modified': True}

                if '_PTS' in method or '_WAK' in method or '_TTS' in method:
                    try:
                        PTS_Serialized = re.search(
                            '_PTS, 1, (NotSerialized|Serialized)', self.dsdt_content).groups()[0]
                    except AttributeError:
                        pass
                    try:
                        WAK_Serialized = re.search(
                            '_WAK, 1, (NotSerialized|Serialized)', self.dsdt_content).groups()[0]
                    except AttributeError:
                        pass
                    try:
                        TTS_Serialized = re.search(
                            '_TTS, 1, (NotSerialized|Serialized)', self.dsdt_content).groups()[0]
                    except AttributeError:
                        pass

                    method_new['\\_SB'] = {'\\_SB.PCI9': {
                        'content': PCI9, 'modified': True}}

                    _PTS = PTS[0] + PTS_Serialized + PTS[1]
                    if '\\_PTS' in method_new['\\']:
                        method_new['\\']['\\_PTS']['content'] += _PTS
                        method_new['\\']['\\_PTS']['modified'] = True
                    else:
                        method_new['\\']['\\_PTS'] = {
                            'content': _PTS, 'modified': True}

                    _WAK = WAK[0] + WAK_Serialized + WAK[1]
                    if '\\_WAK' in method_new['\\']:
                        method_new['\\']['\\_WAK']['content'] += _WAK
                        method_new['\\']['\\_WAK']['modified'] = True
                    else:
                        method_new['\\']['\\_WAK'] = {
                            'content': _WAK, 'modified': True}

                    _TTS = TTS[0] + TTS_Serialized + TTS[1]
                    if '\\_TTS' in method_new['\\']:
                        method_new['\\']['\\_TTS']['content'] += _TTS
                        method_new['\\']['\\_TTS']['modified'] = True
                    else:
                        method_new['\\']['\\_TTS'] = {
                            'content': _TTS, 'modified': True}

        self.method = method_new
        del method_new

    def insert_osi(self):
        '''
        Insert 'If (_OSI ("Darwin"))' into each method to avoid affacting Windows which is booted with OpenCore.
        '''
        for scope in self.method:
            for method in self.method[scope]:
                if not self.method[scope][method]['modified']:
                    # skip unmodified method
                    continue
                if 'Darwin' in self.method[scope][method]["content"]:
                    continue
                stack = []
                method_info = re.search(
                    'Method \((\\\?[\w\.]+), (\d+), (NotSerialized|Serialized)\)',
                    self.method[scope][method]['content']).groups()

                # Insert if _OSI at the beginning
                self.method[scope][method]["content"] = re.sub(
                    'Method \((\\\?[\w\.]+), (\d+), (NotSerialized|Serialized)\)',
                    "Method (%s, %s, %s) \n{ \nIf (_OSI (\"Darwin\"))" % (
                        method_info[0], method_info[1], method_info[2]),
                    self.method[scope][method]["content"])

                for index in range(0, len(self.method[scope][method]["content"])):
                    if "{" in self.method[scope][method]['content'][index]:
                        stack.append('{')
                    if "}" in self.method[scope][method]['content'][index]:
                        stack.pop()
                        if len(stack) == 1:
                            arg = ''
                            for i in range(0, int(method_info[1])):
                                if i > 0:
                                    arg += ', '
                                arg += 'Arg%d' % i
                            # Insert return original method at the bottom
                            self.method[scope][method]["content"] = self.method[scope][method]['content'][:index] + \
                                "}\n        Else\n        {\n            Return(X%s(%s))\n        }\n" % (
                                method_info[0][-3:], arg) + self.method[scope][method]["content"][index:]
                            break

    def special_devices(self):
        '''
        This method automatically patch some special laptops. For example, some HP laptop have ACEL device,
        which will cause battery info not able to be updated.
        '''

        def patch_ACEL(self):
            '''
            Disable HP laptops' ACEL device
            '''
            print("Patching ACEL...")
            content = get_content.search(self.dsdt_content, "(ACEL)")
            for dev in content:
                if dev not in self.method:
                    self.method[dev] = {}
                self.method[dev]["%s._STA" % dev] = {
                    'content': ACEL_STA,
                    'modified': True
                }

        if "Device (ACEL)" in self.dsdt_content:
            if "HPQOEM" not in self.dsdt_content:
                print(IS_THIS_HP_LAPTOP)
                inp = input()
                if inp == 'yes' or inp == 'y':
                    patch_ACEL(self)
            patch_ACEL(self)

    def generate_comment(self):
        # Find mutex and set them to zero
        self.patch_list = []
        mutex = re.findall("Mutex \((.*?), (.*?)\)", self.dsdt_content)
        for item in mutex:
            patch = {}
            name = item[0]
            value = int(item[1], 16)
            find = replace = '01'
            if value != 0:
                for c in name:
                    asc = ord(c)
                    find += "%02X" % asc
                    replace += "%02X" % asc
                find += "%02X" % value
                replace += "00"
                patch['comment'] = '[BATT] Set mutex %s to zero' % name
                patch['find'] = find
                patch['replace'] = replace
                self.patch_list.append(patch)

        # generate ACPI patch
        for scope in self.method:
            for method in self.method[scope]:
                if not self.method[scope][method]['modified']:
                    # Skip unmodified method
                    continue
                patch = {}
                method_name = re.split(r'[\.\\]', method)[-1]
                try:
                    method_info = list(re.search("Method \((%s), (\d+?), (Serialized|NotSerialized)\)" % method_name,
                                                 self.method[scope][method]["content"]).groups())
                except AttributeError:
                    continue
                method_info[0] = method_info[0].replace("\\", "")
                if method_info[0] in dangerous_patch_list:
                    # Warning user if this tool patched some dangerous methods
                    print(DANGEROUS_PATCH_MSG[0], method_info[0], DANGEROUS_PATCH_MSG[1],
                          'X%s' % method_info[0][1:], DANGEROUS_PATCH_MSG[2])
                method_info[1] = int(method_info[1])
                if method_info[2] == 'Serialized':
                    method_info[1] += 8
                find = replace = ''
                for c in method_info[0]:
                    asc = ord(c)
                    find += "%02X" % asc
                    replace += "%02X" % asc
                replace = "58" + replace[2:]  # Set the 1st character to 'X'
                find += "%02X" % method_info[1]
                replace += "%02X" % method_info[1]
                patch['comment'] = '[BATT] Rename %s to X%s' % (
                    method_info[0], method_info[0][1:])
                patch['find'] = find
                patch['replace'] = replace
                self.patch_list.append(patch)

        # Add comment before dsl file
        self.comment += '/*\n'
        self.comment += '* This battery hot patch is generate by SSDT-BATT_Auto_Gen, \n'
        self.comment += '* which is a python program written by Eric Kwok.\n'
        self.comment += '*\n'
        self.comment += '* Note: Should be compile with -f option.\n'
        self.comment += '* For any support, plese visit https://github.com/the-eric-kwok/SSDT-BATT_Auto_Gen/issues\n'
        self.comment += '*\n'
        for patch in self.patch_list:
            self.comment += '* %s\n' % patch['comment']
            self.comment += '* Find:    %s\n' % patch['find']
            self.comment += '* Replace: %s\n' % patch['replace']
            self.comment += '*\n'
        self.comment += '*/\n'

    def assemble(self):
        '''
        Grab comments, head, body, tail, and assemble them together.
        '''
        self.file_generated = self.comment
        self.file_generated += (self.head + self.RW_method)
        for scope in self.method:
            have_method = False
            for method in self.method[scope]:
                if self.method[scope][method]:
                    have_method = True
            if not have_method:
                # Skip empty scope
                continue
            self.file_generated += "    Scope (%s)\n    {\n" % scope
            for method in self.method[scope]:
                if not self.method[scope][method]['modified']:
                    # Skip unmodified method
                    continue
                self.file_generated += self.method[scope][method]["content"] + '\n'
            self.file_generated += "    }\n"
        self.file_generated += '}\n'

    def re_indent(self):
        stack = []
        splited = self.file_generated.split('\n')
        # Parse line by line
        for index in range(0, len(splited)):
            # Delete space at front of each line
            splited[index] = splited[index].strip()
            count = splited[index].count('{')
            count -= splited[index].count('}')
            if count < 0:
                for i in range(0, -count):
                    stack.pop()
            # Indent by brackets
            splited[index] = "    " * len(stack) + splited[index]
            if count > 0:
                for i in range(0, count):
                    stack.append('{')

        self.file_generated = '\n'.join(splited)

    def write_file(self):
        '''
        Write to dsl file, and also try to compile it automatically.
        '''
        out_path = []
        out_path.append(os.path.expanduser('~') + os.sep +
                        'Desktop' + os.sep + 'Battery_hotpatch')
        # Replace DSDT with SSDT-BATT and fill it in filename
        out_path.append(os.path.split(
            self.filepath.replace("DSDT", "SSDT-BATT"))[1])
        # Replace dsdt with SSDT-BATT in filename
        out_path[1] = out_path[1].replace("dsdt", "SSDT-BATT")

        if not os.path.exists(out_path[0]):
            # If directory not exists
            os.makedirs(out_path[0])

        out_file = os.sep.join(out_path)
        out_path = out_path[0]
        try:
            with open(out_file, 'x') as f:
                f.write(self.file_generated)
                print(GENERATE_SUCCESSFUL_MSG)
        except FileExistsError:
            for i in range(1, 100):
                test = '.'.join(out_file.split('.')[:-1]) + '_%d.dsl' % i
                try:
                    with open(test, 'x') as f:
                        f.write(self.file_generated)
                        out_file = test
                        print(GENERATE_SUCCESSFUL_MSG)
                    break
                except FileExistsError:
                    pass

        if os.path.exists('./iasl') and os.sys.platform == "darwin":
            with os.popen("./iasl -va -f %s 2>&1" % out_file) as p:
                ret = p.read()
                if "AML Output" in ret:
                    ret_spl = ret.splitlines()
                    for line in ret_spl:
                        if line.startswith("AML Output"):
                            if ' 0 bytes' not in line:
                                print(COMPILE_SUCCESS_MSG)
                                break
                            else:
                                print(COMPILE_FAILED_ERR)
                                print(ret)
                else:
                    print(COMPILE_FAILED_ERR)
        elif os.path.exists('.\\iasl.exe') and os.sys.platform == 'win32':
            with os.popen(".\\iasl.exe -va -f %s" % out_file) as p:
                ret = p.read()
                if "AML Output" in ret:
                    ret_spl = ret.splitlines()
                    for line in ret_spl:
                        if line.startswith("AML Output"):
                            if '0 bytes' not in line:
                                print(COMPILE_SUCCESS_MSG)
                                break
                            else:
                                print(COMPILE_FAILED_ERR)
                                print(ret)
                else:
                    print(COMPILE_FAILED_ERR)
        else:
            print(TRY_TO_COMPILE_ANYWAY)
            os.system('iasl -va -f %s' % out_file)

        if os.sys.platform == "darwin":
            os.system("open " + out_path)
        elif os.sys.platform == "win32":
            os.system("start " + out_path)


def opener(filepath: str):
    try:
        with open(filepath, 'r') as f:
            content = f.read()
            return content
    except UnicodeDecodeError:
        with open(filepath, 'rb') as fb:
            rawdata = fb.read()
            for encoding in ('ascii', 'utf8', 'gbk', 'latin1'):
                try:
                    content = rawdata.decode(encoding)
                    return content
                except UnicodeDecodeError:
                    pass
            try:
                content
            except NameError:
                if __CHARDET__:
                    guessing = chardet.detect(rawdata)
                    if guessing['confidence'] > 0.5:
                        content = rawdata.decode(guessing['encoding'])
                        return content
                raise RuntimeError('File encoding not known')
    except FileNotFoundError:
        print(FILE_NOT_FOUND_ERR)
        exit(1)
    except PermissionError:
        print(PERMISSION_ERR)
        exit(1)


def show_help():
    print(HELP_MESSAGE)
    exit()


def parse_args():
    '''
    Parsing arguments and load file contents

    @return: (filename, filepath, dsdt_content) - tuple(str)
    '''
    global VERBOSE, DEBUG, FORCE
    filename = filepath = dsdt_content = None
    arg_lens = len(sys.argv)
    if arg_lens == 1:
        show_help()
    for arg in sys.argv:
        if '-h' in arg or 'help' in arg:
            show_help()
        if '-v' in arg:
            VERBOSE = True
        if '-F' in arg or '--force' in arg:
            FORCE = True
        if '-debug' in arg:
            VERBOSE = True
            DEBUG = True
        if '.dsl' in arg:
            filename = arg
            filepath = os.path.abspath(filename)
            dsdt_content = opener(filepath=filepath)
        if '.aml' in arg or '.dat' in arg:
            if os.path.exists('./iasl') and os.sys.platform == "darwin":
                # print("file: "+arg)
                with os.popen('./iasl -d "%s" 2>&1' % arg) as p:
                    ret = p.read()
                    if "ASL Output" in ret:
                        print(DECOMPILE_SUCCESS_MSG)
                    else:
                        print(ret)
                        exit(1)
            elif os.path.exists('.\\iasl.exe') and os.sys.platform == 'win32':
                # print("file: "+arg)
                with os.popen('.\\iasl.exe -d "%s" 2>&1' % arg) as p:
                    ret = p.read()
                    if "ASL Output" in ret:
                        print(DECOMPILE_SUCCESS_MSG)
                    else:
                        print(ret)
                        exit(1)
            else:
                print(NO_IASL_COMPILER)
                exit(1)
            filename = arg.replace('.aml', '.dsl')
            filepath = os.path.abspath(filename)
            dsdt_content = opener(filepath=filepath)
    if filepath and dsdt_content:
        return (filepath, dsdt_content)
    else:
        show_help()


if __name__ == '__main__':
    start_time = time.time()
    filepath, dsdt_content = parse_args()

    result = re.findall("PNP0C0A", dsdt_content)
    if not FORCE:
        if len(result) > 1:
            print(TOO_MANY_BATT_ERR)
            exit(1)
        elif len(result) < 1:
            print(TOO_FEW_BATT_ERR)
            exit(1)

    # Single battery device
    app = AutoGen(filepath=filepath, dsdt_content=dsdt_content)
    if VERBOSE:
        print("程序执行用时", time.time() - start_time, "秒")
